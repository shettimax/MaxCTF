<?php

namespace App\Http\Controllers;

use App\Models\Department;
use App\Models\Faculty;
use App\Models\FeeItem;
use App\Models\FeeManager;
use App\Models\PaymentOption;
use App\Models\Programme;
use App\Models\RegistrationPeriod;
use App\Models\Reservation;
use App\Models\SessionalFeesSetting;
use App\Models\Student;
use App\Models\StudentBiodata;
use App\Models\SundryTransaction;
use App\Models\Transaction;
use Auth;
use Illuminate\Http\Request;


class FeesController extends Controller
{
    //

    public function __construct()
    {
        $this->middleware(["auth:student", "mmode"]);
    }

    public function dashboard(Request $request)
    {

        $student = Auth::user();
        return view('pages.student.fees.dashboard', compact('student'));

    }

    public function sundry(Request $request)
    {
        $student = Auth::user();
        $sundrySessions = SundryTransaction::where(['payer_id' => $student->id, 'code' => 'PSC', "payer_type" => "Student"])->orderBy('session', 'DESC')->get();
        return view('pages.student.fees.sundry', compact('student', 'sundrySessions'));
    }

    public function osc(Request $request)
    {
        $student = Auth::user();
        $payItems = FeeItem::where('code', 'OSC')->get();
        return view('pages.student.fees.osc', compact('student', 'payItems'));
    }

    public function index()
    {
        try {
            $student = Auth::user();
            $transactions = Transaction::where(["student_id" => $student->id,])->whereIn("code", ["REG", "RST"])->whereNotNull("invoice_number")->get();
            $transactions2 = Transaction::where(["code" => "ACC"])->whereIn("student_id", Reservation::where("student_id", $student->id)->pluck('id'))
                ->whereNotNull("invoice_number")->get();

//            $pt = new Portal;
//            $pt->fetchPGStudent($student->matric_number);
            foreach ($transactions as $transaction) {
                try {
                    $response = $transaction->verify();
                    $transaction->makeLogs();

                } catch (\Exception $e) {

                }

            }
            foreach ($transactions2 as $transaction) {
                try {
                    $response = $transaction->verify();
                } catch (\Exception $e) {

                }

            }
            $sessions = $student->payableSessions();//$arr;
            $fees = [];
            $resess = [];

            foreach ($sessions as $session) {
                $student->mySessionReg($session)->applyPrivatePaymentOption();
                $fees[$session] = ["session" => $session, "content" => $student->sessionFees($session)];
                $ret = $student->entry_session == $session ? "New" : "Returning";
                $resess[] = ["session" => $session, "programme_id" => $student->sessionProgramme($session)->id, "nature" => "FEE", "new_returning" => $ret];
            }
//            return $fees;
            return view("pages.student.fees.index", compact("fees"));
        } catch (\Exception $exception) {
            return $exception->getMessage() . "\r" . $exception->getTraceAsString();
        }


    }

    public function transactionView($session)
    {
        $student = Auth::user();
        $student->mySessionReg($session)->applyPrivatePaymentOption();
        $records = $student->sessionFees($session);
        $sessions = $student->payableSessions()->all();// show Oops invalid session if session not in list
        $fees = $records["fees"];
        $waived = $records["waived"];
        $transactions = $records["transaction"];
        $total = $records["total"];
        $percentage = $records["percentage"];
        $amountpaid = $records["amountpaid"];
        $balance = $total - $amountpaid;
        $biodata = $student->biodata();
        if (!$biodata || ($student->religion == null || empty($student->religion))) {
            return view("pages.student.fees.error");
        }
        // return $session;
        if (!in_array($session, (array)$sessions))
            return view("pages.student.fees.invalidsession");

        return view("pages.student.fees.viewtransaction", compact("session", "fees", "waived", "transactions", "percentage", "balance", 'student'));

    }

    public function paySundry($session)
    {
        $student = Auth::user();
        $programme = Programme::find($student->programme_id);
        $department = Department::find($programme->department_id);
        $faculty = Faculty::find($department->faculty_id);
        // if (!$student->isNew()) {
        $fees = FeeManager::computeStudentSundryCharges($student, $session);
        $amount = 0;
        foreach ($fees as $fee) {
            $amount += $fee->amount;
        }
        $details = SundryTransaction::paySundryStudent($student, $amount, $session);
        $transactions = $details["transactions"];
        $amountPaid = $details["totalAmountPaid"];
        $studentbiodata = StudentBiodata::where(["student_id" => $student->id])->first();

//            if ($session >= 2018 && ($amount - $amountPaid > 0)) {

        return view("pages.student.transaction.fees.localtransaction", compact("fees", "session", "studentbiodata", "transactions", "student", "faculty"));
//            }
        // }
        //return redirect(route("fees.session"));
    }

    public function payViva($session)
    {
        $student = Auth::user();
        $programme = Programme::find($student->programme_id);
        $department = Department::find($programme->department_id);
        $faculty = Faculty::find($department->faculty_id);
        // if (!$student->isNew()) {
        $fees = FeeManager::computeStudentSundryCharges($student, $session);
        $amount = 0;
        foreach ($fees as $fee) {
            $amount += $fee->amount;
        }
        $details = SundryTransaction::payVivaStudent($student, $amount, $session);
        $transactions = $details["transactions"];
        $amountPaid = $details["totalAmountPaid"];
        $studentbiodata = StudentBiodata::where(["student_id" => $student->id])->first();

//            if ($session >= 2018 && ($amount - $amountPaid > 0)) {

        return view("pages.student.transaction.fees.viva", compact("fees", "session", "studentbiodata", "transactions", "student", "faculty"));
//            }
        // }
        //return redirect(route("fees.session"));
    }

    public function sessionView($session)
    {
        try {
            $student = Auth::user();

            $records = $student->sessionFees($session);
            $sessions = $student->payableSessions()->all();// show Oops invalid session if session not in list
            $fees = $records["fees"];
//                if($student->id == 36048795){
//                    return $fees;
//                }
            $waived = $records["waived"];
            $transactions = $records["transaction"];
            $total = $records["total"];
            $percentage = $records["percentage"];
            $amountpaid = $records["amountpaid"];
            $balance = $total - ($amountpaid + $waived);
            $biodata = $student->biodata();
            $trans = $transactions;

            if (!$biodata || ($student->religion == null || empty($student->religion))) {
                return view("pages.student.fees.error");
            }
            // return $session;
            if (!in_array($session, (array)$sessions))
                return view("pages.student.fees.invalidsession");
            if ($student->feesClearedForSession($session)) {
                return view("pages.student.fees.viewtransaction", compact("fees", "session", "transactions", "percentage", "trans"));
            }
//        return compact("fees","percentage","session","amountpaid","balance","total","waived","transactions");
            return view("pages.student.fees.paymentoptions", compact("fees", "percentage", "session", "amountpaid", "balance", "total", "waived", "transactions", "student"));

        } catch (\Exception $exception) {
            return $exception->getMessage();
        }
    }

    public function others(Request $request)
    {
        $student = Auth::user();
        return view('pages.student.fees.others', compact('student'));
    }

    public function viva(Request $request)
    {
        $student = Auth::user();
        //search if there is at least a payment for viva
        $vivaPayment = SundryTransaction::where(['payer_id' => $student->id, 'code' => 'VMF', 'payer_type' => "Student"])->where('payment_status', "<>", 'Not Paid')->first();
        //Get the configuration of latest session, since you pay once and you have to pay what is due when you
        //want to pay, because some will pay even it wasn't there when they were admitted & payment is once
        $sessionalFeeSetting = SessionalFeesSetting::where(['fee_type' => 'VMF', 'programme_type' => 'PG'])->orderBy('session', 'DESC')->first();
        //Some may have already paid and the fee might change , since it will check if you have paid once before
        //if there is payment before compute with the session of that payment else use the latest config
        $session = $vivaPayment ? $vivaPayment->session : $sessionalFeeSetting->fee_session;
        //Erase any non paid transaction that has different session from the one to be computed
        SundryTransaction::where(['payer_id' => $student->id, 'code' => 'VMF', 'payment_status' => 'Not Paid', 'payer_type' => "Student"])
            ->where('session', '<>', $session)->delete();
        //Compute total Paid
        $amountPaid = SundryTransaction::where(['payer_id' => $student->id, 'code' => 'VMF', 'session' => $session, 'payer_type' => "Student"])->where('payment_status', "<>", 'Not Paid')->sum('transaction_amount');
        $fees = FeeManager::computeStudentSundryCharges($student, $session, 'VMF');
        $amountDue = 0;
        foreach ($fees as $fee) {
            $amountDue += $fee->amount;
        }

        $balance = $amountDue - $amountPaid;
        $balance = $balance > 0 ? $balance : 0;
        //check if amount paid equals amount due else create transaction for pending balance
        if ($amountPaid >= $amountDue) {
            $transactions = SundryTransaction::where(['payer_id' => $student->id, 'code' => 'VMF', 'session' => $session, 'payer_type' => "Student"])->get();
            $trans = $transactions[0];
        } else {
            //Check if there is an unpaid transaction with that amount($balance) iff no create one
            if (!$trans = SundryTransaction::where(['payer_id' => $student->id, 'code' => 'VMF', 'payment_status' => 'Not Paid', 'session' => $session, 'transaction_amount' => $balance, 'payer_type' => "Student"])->first()) {
                $trans = new SundryTransaction();
                $trans->payer_id = $student->id;
                $trans->code = "VMF";
                $trans->transaction_code = "VMF" . ($session % 2000) . "-" . time();
                $trans->transaction_amount = $balance;
                $trans->session = $session;
                $trans->payment_status = "Not Paid";
                $trans->payer_type = "Student";
                $trans->collected_by = 0;
                $trans->save();
            }
            $transactions = SundryTransaction::where(['payer_id' => $student->id, 'code' => 'VMF', 'session' => $session, 'payer_type' => "Student"])->get();
        }
        return view('pages.student.fees.viva', compact('session', 'trans', 'transactions', 'student', 'fees', 'balance'));
    }

    public function acceptance()
    {
        $student = Auth::user();
        $biodata = $student->biodata();
        if (!$biodata || ($student->religion == null || empty($student->religion)) || !$biodata->email) {
            return view("pages.student.fees.error");
        }
        $regP = RegistrationPeriod::where(["programmeid" => $student->programme_id, "nature" => "FEE"])->orderBy("session", "DESC")->first();
        $session = $regP ? $regP->session : $student->entrysession;
        $fees = FeeManager::computeStudentSundryCharges($student, $session)[0];
        $amount = $fees->amount;
//        foreach($fees as $fee){
//            $amount += $fee->amount;
//        }
//        return $amount;
        $fees = [$fees];
        $details = SundryTransaction::paySundryStudent($student, $amount, $session);
        $transactions = $details["transactions"];
        $amountPaid = $details["totalAmountPaid"];
        $studentbiodata = StudentBiodata::where(["student_id" => $student->id])->first();
//        return [Transaction::makeTransaction($transactions,"ACP")];
        $invoice = json_decode(Transaction::makeTransaction($transactions, "ACP"));
        if ($invoice->Error == false) {
            $transactions->invoice_number = $invoice->ResponseObject->InvoiceNumber;
            $transactions->save();
            return view("pages.student.transaction.fees.localtransaction", compact("invoice", "fees", "session", "studentbiodata", "transactions", "student"));

        } else {
            return redirect()->route('dashboard.index');
        }

    }

    public function process(Request $request)
    {
        $student = Auth::user();
        $biodata = $student->biodata();
        if (!$biodata || ($student->religion == null || empty($student->religion)) || !$biodata->email) {
            return view("pages.student.fees.error");
        }

        $sessions = $student->payableSessions()->all();// show Oops invalid session if session not in list
        if (!in_array($request->input('session'), (array)$sessions))
            return view("pages.student.fees.invalidsession");

        $perc = decrypt($request->_g3p8du_xd7_3wyh_i_);
        $records = $student->sessionFees($request->input('session'));
        $totalAmount = $records["total"];
        $amountpaid = $records["amountpaid"];
        $balance = $totalAmount - $amountpaid;
        $session = $request->input('session');
        //return $perc[0];
        if ($perc[0] == 'o') {
            $this->validate($request, [
                "amount" => "required|integer"
            ]);

            if (intval($request->amount) < 10000) {
                return redirect()->back()->withErrors(["amount" => "You are not allowed to pay less than N10,000."]);
            }
            $computedAmount = $request->amount;
            if ($request->amount > $balance) {
                return view("pages.student.fees.excess", compact("session"));
            } else if ($request->amount < 10000) {
                return view("pages.student.fees.short", compact("session"));
            }

        } elseif ($perc[0] == 'r') {
            $computedAmount = $balance;
        } elseif ($perc[0] == 'x') {
            $computedAmount = ($totalAmount * (30 / 100)) - $amountpaid;
        } elseif ($perc[0] == '1' || $perc[0] == '5' || $perc[0] == '3') {
            $percentage = 100;
            if ($perc[0] == '5') $percentage = 50;
            if ($perc[0] == '3') $percentage = 30;

            $computedAmount = $totalAmount * $percentage / 100;
            if ($computedAmount > $balance) {
                return view("pages.student.fees.excess", compact("session"));
            }
        }

        $code = FeeManager::generateTransactionCode($student->id, "REG", $request->input('session'), $student->mode_of_entry[0] . "R", $computedAmount, $totalAmount);
        $trans = Transaction::where("transcode", "=", $code)->first();

        return redirect()->route("transaction.fees.generaterrr", [$trans->id]);

        return [$perc[0], $records, $sessions];
    }

    public function payFee($session, $value)
    {
        $student = Auth::user();
        $biodata = $student->biodata();
        if (!$biodata || $student->religion == null || empty($student->religion) || !filter_var($biodata->email, FILTER_VALIDATE_EMAIL)) {
            return view("pages.student.fees.error");
        }
        $records = $student->sessionFees($session);
        // return $records;
        $sessions = $student->payableSessions()->all();// show Oops invalid session if session not in list

        if (!in_array($session, (array)$sessions))
            return view("pages.student.fees.invalidsession");

        if ($records["percentage"] >= 100)
            return view("pages.student.fees.completedpayment");

        $fees = $records["fees"];
        $percentage = $records["percentage"];
        $total = $records["total"];
        $amountpaid = $records["amountpaid"] + $records["waived"];
        $balance = $total - $amountpaid;
        $option = substr($value, 0, 1);

//        $records = $student->sessionFees($session);
        $totalAmount = $records["total"];
        $amountpaid = $records["amountpaid"] + $records["waived"];
        $balance = $totalAmount - $amountpaid;
        $code = FeeManager::generateTransactionCode($student->id, "REG", $session, Transaction::code($student->mode_of_entry), $balance, $totalAmount);
        $trans = Transaction::where("transaction_code", "=", $code)->first();
        return back();
        return view("pages.student.fees.paymentcompute", compact("balance", "session", "option", "percentage", "fees", "amountpaid", "trans"));

    }

    public function openTransaction(Request $request, $id)
    {
        $student = Auth::user();
        $transaction = Transaction::find($id);
        if ($transaction) {
            $biodata = $student->biodata();
            $transactionStudent = $transaction->student();
            if ($transactionStudent->id != $student->id) {
                return back();
            }
            if (!$biodata || $student->religion == null || empty($student->religion) || !filter_var($biodata->email, FILTER_VALIDATE_EMAIL)) {
                return view("pages.student.fees.error");
            }
            $session = $transaction->session;
            $sessions = $student->payableSessions()->all();// show Oops invalid session if session not in list

            if (!in_array($session, (array)$sessions))
                return view("pages.student.fees.invalidsession");

            $records = $student->sessionFees($session);
            if ($records["percentage"] >= 100)
                return view("pages.student.fees.completedpayment");

            $fees = $records["fees"];
            $percentage = $records["percentage"];
            $totalAmount = $records["total"];
            $amountpaid = $records["amountpaid"] + $records["waived"];
            $balance = $totalAmount - $amountpaid;
            $trans = $transaction;
            return view("pages.student.fees.paymentcompute", compact("balance", "session", "percentage", "fees", "amountpaid", "trans"));
        }
        return 0;
    }

    public function generateRRR(Request $request, $id)
    {
        if (!$trans = Transaction::find($id)) {
            return back()->withErrors(['err_message' => "Invalid Transaction"]);
        }
        $student = $trans->student();
        $biodata = $student->biodata();
        $session = $trans->session;
        if ($trans->invoice_number == "") {
            $serviceTypes = [
                "UG" => Transaction::FEESERVICETYPEID,
                "AD" => Transaction::DPFEESSERVICETYPEID,
                "HD" => Transaction::DPFEESSERVICETYPEID,
                "DP" => Transaction::DPFEESSERVICETYPEID,
                "ND" => Transaction::DPFEESSERVICETYPEID,
                "PD" => Transaction::DPFEESSERVICETYPEID,
                "LV" => Transaction::LVTFEESSERVICETYPEID,
                "PG" => Transaction::PGFEESERVICETYPEID
            ];
            $customeFields = [
                ["name" => "Matric No", "value" => $student->matric_number, "type" => "All"],
                ["name" => "Session", "value" => $session, "type" => "All"],
                ["name" => "Transaction Code", "value" => $trans->transaction_code, "type" => "All"],
            ];
            if ($trans->code == "RST") {
                foreach ($student->resits($session) as $fields) {
                    if ($fields->course_unit == 0) {
                        [$code, $title] = [$fields->code_title, $fields->code_title];
                    } else {
                        [$code, $title] = explode('|', $fields->code_title);
                    }
                    $customeFields[] = ['name' => strtoupper($code), "value" => $title, "type" => "All"];
                }
            }

            $mert = Transaction::MERCHANTID;
            $servType = $serviceTypes[strtoupper($student->mode_of_entry)];
            $concatString = Transaction::MERCHANTID . $servType . $trans->transaction_code . intval($trans->transaction_amount) . Transaction::APIKEY;
            $hash = hash('sha512', $concatString);
            $data = [
                "serviceTypeId" => $servType,
                "amount" => intval($trans->transaction_amount),
                "payerName" => $student->getFullName(),
                "description" => "Registration Charges",
                "payerEmail" => $biodata->email,
                "payerPhone" => $biodata->gsm,
                "orderId" => $trans->transaction_code,
                "customFields" => $customeFields
            ];
            $data_string = json_encode($data);
            $ch = curl_init("https://login.remita.net/remita/exapp/api/v1/send/api/echannelsvc/merchant/api/paymentinit");
            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "POST");
            curl_setopt($ch, CURLOPT_POSTFIELDS, $data_string);
            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
            curl_setopt($ch, CURLOPT_HTTPHEADER, array(
                "Authorization: remitaConsumerKey=$mert,remitaConsumerToken=$hash",
                'Content-Type: application/json',
                'Content-Length: ' . strlen($data_string)
            ));
            $response = curl_exec($ch);
            curl_close($ch);
            $response = substr($response, 7);
            $response = substr($response, 0, -1);
            $response = json_decode($response);
            if (isset($response->statuscode) && $response->statuscode == "025") {
                $trans->invoice_number = $response->RRR;
                $trans->save();
                return back()->withErrors(['scs_message' => "RRR Generated"]);
            } else {
                return back()->withErrors(['wrn_message' => "Failed to generate RRR please try again later."]);
            }
        }
        return back()->withErrors(['wrn_message' => "Transaction has RRR"]);
    }

    public function roundUp($value, $nearest = 1000)
    {

        return (int)($nearest * ceil($value / $nearest));
    }

    public function showPay($enc_id)
    {
        //
        $user = Auth::user();
        $student = Student::find(decrypt($enc_id));
        $studentid = $student->students;
//        $fees = FeeManager::computeSundryCharges($student);
        $fees = FeeManager::computeStudentSundryCharges($student);
        $amount = 0;
        foreach ($fees as $fee) {
            $amount += $fee->amount;
        }
        $transactions = SundryTransaction::paySundryStudent($student, $amount)->get();
        $transaction = $transactions[0];
        if ($transaction->transamount != $amount) {
            $transaction->transamount = $amount;
            $transaction->save();
        }
        $std = $student->student()->first();
        $biodata = $std->biodata();
        $contact = $student->contact();
        if (!$student)
            return view('errors.record.view');
        return view("pages.student.fees.localtransaction", compact("student", "fees", "transactions", "biodata", "transaction", "contact", "user", "form"));

    }

    public function admissionletter()
    {
        return view("pages.student.fees.admissionletter");
    }

    public function screeningform()
    {
        return view("pages.student.fees.screeningform");
    }

    public function clearance()
    {
        return view('pages.student.errors.clearance');
    }

    public function wallet(Request $request)
    {
        return view('pages.student.abumfb.wallet');
    }

    public function paymentOptionChoose(Request $request, $session, $paymentOptionId)
    {
        $student = Auth::user();
        if (!$student->mySessionReg($session)->getPaymentOptions($paymentOptionId)) {
            return abort(404);
        }
        $sessReg = $student->mySessionReg($session);
        $sessReg->chosen_plan_id = $paymentOptionId;
        $sessReg->save();

        return back();
    }

    public function paymentOptionGenerateTransaction(Request $request, $session, $index)
    {
        $student = Auth::user();
        $sessionReg = $student->mySessionReg($session);
        $fees = $student->sessionFees($session);
        $due = $fees['total'];
        $paid = $fees['amountpaid'];
        $waived = $fees['waived'];
        $cleared = $paid + $waived;
        $balance = $due - $cleared;

        if ($index == "h") {
            $fees = (object)$fees["fees"];
            $code = FeeManager::generateTransactionCode($student->id, "REG", $session, Transaction::code($student->mode_of_entry), $balance, $due);
            $trans = Transaction::where("transaction_code", "=", $code)->first();
            return view("pages.student.fees.paymentcompute", compact("balance", "session", "fees", "trans"));
        }

        $trnx = Transaction::where(
            [
                'student_id' => $student->id,
                "code" => "REG"
            ])->orderBy('flexible_index', "DESC")->whereNotNull('flexible_index')->first();
        $nextIndex = $trnx ? ($trnx->flexible_index + 1) : 0;
        if ($trnx && $trnx->payment_status == "Not Paid") {
            return back();
        }

        $pOpt = PaymentOption::find($sessionReg->chosen_plan_id);
        if (!$pOpt) {
            return back();
        }

        $threnches = explode(":", $pOpt->value);

        if (!isset($threnches[$nextIndex])) {
            return back();
        }
        $thrench = preg_replace("/[^0-9]/", "", $threnches[$nextIndex]);;

        $thisPerc = ($thrench / 100) * $due;
        if ($balance <= $thisPerc) {
            return back();
        }
        $equiv = $student->transEquiv($session, $thisPerc);
        if ($equiv) {
            $equiv->flexible_index = $equiv->flexible_index ? $equiv->flexible_index : $nextIndex;
            $equiv->save();
            return back();
        }

//        $code = FeeManager::generateTransactionCode(, "REG", $session, , $thisPerc, $due);
        $transcode = FeeManager::getTransCode(Transaction::code($student->mode_of_entry . $thrench . "-"));
        $transaction = new Transaction();
        $transaction->student_id = $student->id;
        $transaction->transaction_code = $transcode;
        $transaction->code = "REG";
        $transaction->transaction_amount = $thisPerc;
        $transaction->session = $session;
        $transaction->payment_status = 'Not Paid';
        $transaction->percentage = $thrench;
        $transaction->flexible_index = $nextIndex;
        $transaction->save();

        return back();

    }

    public function oscView(Request $request, $id)
    {
        $student = Auth::user();
        return $feeItem = FeeItem::find($id);
        //search if there is at least a payment for viva
        $vivaPayment = SundryTransaction::where(['payer_id' => $student->id, 'code' => 'VMF', 'payer_type' => "Student"])->where('payment_status', "<>", 'Not Paid')->first();
        //Get the configuration of latest session, since you pay once and you have to pay what is due when you
        //want to pay, because some will pay even it wasn't there when they were admitted & payment is once
        $sessionalFeeSetting = SessionalFeesSetting::where(['fee_type' => 'VMF', 'programme_type' => 'PG'])->orderBy('session', 'DESC')->first();
        //Some may have already paid and the fee might change , since it will check if you have paid once before
        //if there is payment before compute with the session of that payment else use the latest config
        $session = $vivaPayment ? $vivaPayment->session : $sessionalFeeSetting->fee_session;
        //Erase any non paid transaction that has different session from the one to be computed
        SundryTransaction::where(['payer_id' => $student->id, 'code' => 'VMF', 'payment_status' => 'Not Paid', 'payer_type' => "Student"])
            ->where('session', '<>', $session)->delete();
        //Compute total Paid
        $amountPaid = SundryTransaction::where(['payer_id' => $student->id, 'code' => 'VMF', 'session' => $session, 'payer_type' => "Student"])->where('payment_status', "<>", 'Not Paid')->sum('transaction_amount');
        $fees = FeeManager::computeStudentSundryCharges($student, $session, 'VMF');
        $amountDue = 0;
        foreach ($fees as $fee) {
            $amountDue += $fee->amount;
        }

        $balance = $amountDue - $amountPaid;
        $balance = $balance > 0 ? $balance : 0;
        //check if amount paid equals amount due else create transaction for pending balance
        if ($amountPaid >= $amountDue) {
            $transactions = SundryTransaction::where(['payer_id' => $student->id, 'code' => 'VMF', 'session' => $session, 'payer_type' => "Student"])->get();
            $trans = $transactions[0];
        } else {
            //Check if there is an unpaid transaction with that amount($balance) iff no create one
            if (!$trans = SundryTransaction::where(['payer_id' => $student->id, 'code' => 'VMF', 'payment_status' => 'Not Paid', 'session' => $session, 'transaction_amount' => $balance, 'payer_type' => "Student"])->first()) {
                $trans = new SundryTransaction();
                $trans->payer_id = $student->id;
                $trans->code = "VMF";
                $trans->transaction_code = "VMF" . ($session % 2000) . "-" . time();
                $trans->transaction_amount = $balance;
                $trans->session = $session;
                $trans->payment_status = "Not Paid";
                $trans->payer_type = "Student";
                $trans->collected_by = 0;
                $trans->save();
            }
            $transactions = SundryTransaction::where(['payer_id' => $student->id, 'code' => 'VMF', 'session' => $session, 'payer_type' => "Student"])->get();
        }
        return view('pages.student.fees.viva', compact('session', 'trans', 'transactions', 'student', 'fees', 'balance'));

    }

    public function listOsc(Request $request, $id)
    {
        $student = Auth::user();
        $feeItem = FeeItem::find($id);
        if (!$feeItem) {
            return back();
        }
        //search if there is at least a payment for viva
        $oscPayments = SundryTransaction::where(['payer_id' => $student->id, 'code' => 'OSC', 'sub_code' => $feeItem->account_code, 'payer_type' => "Student"])->where('payment_status', 'Paid')->get();
        return view("pages.student.fees.paid_osc", compact('student', 'oscPayments', 'feeItem'));
    }

    public function payOsc(Request $request, $id)
    {
        $user = Auth::user();

        $feeItem = FeeItem::find($id);
        if (!$feeItem) {
            return abort(403);
        }
        $sessionalFeeSetting = SessionalFeesSetting::where(['fee_type' => 'OSC', 'programme_type' => 'PG'])->orderBy('session', 'DESC')->first();
        $session = $sessionalFeeSetting->fee_session;
        $fees = FeeManager::computeStudentSundryCharges($user, $session, 'OSC', 1)->where('fee_item_id', $id)->get();
        $amountDue = 0;
        foreach ($fees as $fee) {
            $amountDue += $fee->amount;
        }
        $trans = SundryTransaction::where(['payer_id' => $user->id, 'code' => 'OSC', 'sub_code' => $feeItem->account_code, 'payer_type' => "Student"])->first();
        if (!$trans) {
            $trans = new SundryTransaction();
            $trans->payer_id = $user->id;
            $trans->code = "OSC";
            $trans->sub_code = $feeItem->account_code;
            $trans->transaction_code = "OSC-" . $feeItem->account_code . ($session % 2000) . "-" . time();
            $trans->transaction_amount = $amountDue;
            $trans->amount_due = $amountDue;
            $trans->session = $session;
            $trans->payment_status = "Not Paid";
            $trans->payer_type = "Student";
            $trans->collected_by = 0;
            $trans->save();
        }
        $transactions = [];
        $balance = $amountDue;
        // return $amountDue;
        //search if there is at least a payment for viva
        // $oscPayments = SundryTransaction::where(['payer_id'=>$student->id,'code'=>'OSC','sub_code'=>$feeItem->account_code,'payer_type'=>"Student"])->where('payment_status','Paid')->get();
        return view("pages.student.fees.payOsc", compact('user', 'feeItem', 'trans', 'fees', 'transactions', 'session', 'balance'));
    }

    public function oscDetails(Request $request, $id)
    {
        $transaction = SundryTransaction::find($id);
        if (!$transaction) {
            return abort(403);
        }
        $fees = FeeItem::where(['account_code' => $transaction->sub_code])->get();
        $feeItem = $fees[0];

        return view('pages.student.fees.paid_osc_details', compact('feeItem', 'transaction', 'fees'));
    }

}
