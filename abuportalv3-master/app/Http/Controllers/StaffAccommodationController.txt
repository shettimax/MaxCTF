<?php

namespace App\Http\Controllers;
use App\Models\Student;;
use App\Models\Hostel;;
use App\Models\Faculty;;
use App\Models\Department;
use App\Models\Programme;;
use App\Models\Block;;
use App\Models\Room;;
use App\Models\RoomConfig;;
use App\Models\AccommodationConfig;;
use App\Models\Reservation;;
use App\Models\ProgrammeType;;
use App\Models\Accommodation;;
use App\Models\CourseRegistration;;
use App\Models\BulkReservationLog;
use App\Services\BulkReservationService;
use Illuminate\Support\Facades\Storage;
use App\Imports\ReservationPreviewImport;
use Carbon\Carbon;
use http\Exception\InvalidArgumentException;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use App\Exports\ReservationTemplateExport;
use Maatwebsite\Excel\Facades\Excel;
use Illuminate\Support\Facades\Log;
class StaffAccommodationController extends Controller
{

    protected $bulkReservationService;
    public function __construct(BulkReservationService $bulkReservationService)
    {
        $this->bulkReservationService = $bulkReservationService;
        $this->middleware('auth:staff');
    }

    public function index()
    {

        $user = Auth::user();
        $permission = "accommodation.index";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        $eligibility = self::checkEligibility(Auth::user());

        if (in_array($eligibility, ['reserved', 'paid', 'claimed', 'waived'])) {
            return redirect(route('accommodation.reservation'));
        } else if (in_array($eligibility, ['spillover', 'accommodation_closed', 'invalid_programme', 'defered', 'part-time', 'notregistered', 'expelled', 'suspended', 'graduated', 'notpaid', 'nobiodata', 'noprofilepix'])) {
            return view('pages.student.accommodation.notentitled', ['reason' => $eligibility]);
        }

        return view('pages.student.accommodation.index');
    }

    public function noprofile($isadmin = false)
    {
        $user = Auth::user();
        $permission = "accommodation.index";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        if ($isadmin) {
            return view('pages.staff.accommodation.reservation.notentitled');
        } else {
            return view('pages.student.accommodation.notentitled');
        }
    }

    public function reservation()
    {


        $eligibility = self::checkEligibility(Auth::user());
        $user = Auth::user();
        $permission = "accommodation.reservation";
        if (!$this->access($user,$permission)){
            return response()->json(["status" => 401, "message" => "You have no permission to do this operation"]);

        }
        $accommodation = Accommodation::orderBy('id', 'desc')->first();
        if ($accommodation->status != 'active') {
            return view('pages.student.accommodation.notentitled', ['reason' => $accommodation->status]);
        }

        if (in_array($eligibility, ['reserved', 'paid', 'claimed', 'waived'])) {
            $reservation = Reservation::where([
                ['student_id', Auth::user()->id],
                ['session', $accommodation->session]
            ])
                ->whereIn('status', ['reserved', 'paid', 'claimed', 'waived'])
                ->first();
            $paidbutexpiredres = Reservation::getPaidButExpiredReservations(Auth::user(), $reservation->session);
            return view('pages.student.accommodation.reserved', array('student' => Auth::user(), "paidbutexpired" => $paidbutexpiredres->count(), 'reservation' => $reservation));
        } else if (in_array($eligibility, ['spillover', 'invalid_programme', 'part-time', 'defered', 'expelled', 'suspended', 'graduated'])) {
            return view('pages.student.accommodation.notentitled', ['reason' => $eligibility]);
        } else if (in_array($eligibility, ['accommodation_closed', 'notregistered', 'notpaid', 'nobiodata'])) {
            return view('pages.student.accommodation.notentitled', ['reason' => $eligibility]);
        }

        $hostels = Accommodation::getReservableHostel(Auth::user());

        return view('pages.student.accommodation.reservation', array('hostels' => $hostels, 'accommodation' => $accommodation));
    }

    /* FOR CRON JOB */

    public function expireReservations(Request $request)
    {
        Reservation::expireReservations();
        return response('', 200);
    }

    /* STUDENT AND ADMIN */
    public static function checkEligibility(Student $student, $isadmin = false)
    {
//        $user = Auth::user();
//        $permission = "student.view";
//        if (!(new Controller())->access($user,$permission))
//            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        if (!$isadmin) {
            //verify if the student is entitled for accommodation
            //determinant (defered, residency, staffintraining, pgd)
            if ($student->isDefered()) {
                return 'defered';
            }
            if (str_contains($student->programme()->programmetype->progtypename, 'Postraduate Diploma')) {
                return 'invalid_programme';
            }
            if ($student->residencyExhausted()) {
                return 'spillover';
            }
            if ($student->hasGraduated()) {
                return 'graduated';
            }


            /* need to uncomment this section*/
            //verify if the student has registered for the session
            $regPeriod = $student->currentSession();
            //$session = $regPeriod->session;
            if (count(CourseRegistration::getCourseRegisteredByStudent($student, $student->currentSession()->session)) == 0) {
                return 'notregistered';
            }

            if (null === $student->biodata() || $student->biodata()->count() == 0) {
                return 'nobiodata';
            }

            if (!file_exists(public_path() . '/studentpics/' . $student->id . '.jpg')) {
                return 'noprofilepix';
            }
        }
        //
        //verify if the student has already booked for accommodation
        $accommodation = Accommodation::where('end_date', null)->orderBy('id', 'desc')->first();
        if (!$accommodation) {
            return 'accommodation_closed';
        }

        $accomstatus = Reservation::where([
            ['student_id', $student->id],
            ['session', $accommodation->session]
        ])->whereIn('status', ['reserved', 'paid', 'claimed', 'waived'])->first();
        if ($accomstatus) {
            //redirect the user to the appropriate page
            return $accomstatus->status;
        }

        return 'eligible';
    }

    public function fetchrooms(Request $request)
    {
        $user = Auth::user();
        $permission = "accommodation.admin.fetchrooms";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        if (true || $request->ajax()) {
            $hostel = $request->query->get('hostel');
            $block = $request->query->get('block');
            $isadmin = ($request->query->get('isadmin') == '1') ? (true) : (false);
            if ($isadmin) {
                $student = Student::findOrFail($request->query->get('studentid'));
            } else {
                $student = Auth::user();
            }

            $hostels = ($hostel == "") ? (Accommodation::getReservableHostel($student, $isadmin)) : (array(Hostel::findOrFail($hostel)));
            $block = ($block == "") ? (null) : (Block::find($block));
            $accommodation = Accommodation::where('end_date', null)->orderBy('id', 'desc')->first();
            if ($isadmin) {
                return view('partialpages.accommodation.fetchrooms', array('accommodation' => $accommodation, 'hostels' => $hostels, 'blck' => $block, 'student' => $student, 'isadmin' => true));
            } else {
                return view('partialpages.accommodation.fetchrooms', array('accommodation' => $accommodation, 'hostels' => $hostels, 'blck' => $block, 'student' => $student, 'isadmin' => false));
            }
        } else {
            abort(403, 'Invalid Request!');
        }
    }

    public function reserve(Request $request)
    {

//        accommodation.admin.backendreserve
        $user = Auth::user();
        $permission = "accommodation.admin.backendreserve";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        $isadmin = ($request->request->get('isadmin') == '1') ? (true) : (false);
        $student = Auth::user();
        if ($isadmin) {
            $student = Student::findOrFail($request->request->get('studentid'));
        }
        $eligibility = self::checkEligibility($student, $isadmin);
        
        if (in_array($eligibility, ['reserved', 'paid', 'claimed', 'waived'])) {
            return response('', 204);
        } else if (in_array($eligibility, ['accommodation_closed', 'notpaid', 'nobiodata', 'noprofilepix'])) {
            return response('', 403);
        } else if (!$isadmin && in_array($eligibility, ['spillover', 'invalid_programme', 'part-time', 'defered', 'not_registered', 'expelled', 'suspended', 'graduated'])) {
            return response('', 403);
        }

        $id = $request->request->get('rid');

        $roomconfig = RoomConfig::find($id);
        $reservation = Reservation::reserve($roomconfig, $student, $isadmin);
        if ($reservation == 'error') {
            return response('', 500);
        } else if ($reservation == 'alreadyreserved') {
            return response('', 204);
        } else {
            return response('', 200);
        }
    }

    public function cancelReservation(Request $request, $id)
    {

        $user = Auth::user();
        $permission = "accommodation.admin.cancelreservation";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        $reservation = Reservation::findOrFail($id);
        $student = $reservation->student;
        if (!(Auth::user() instanceof Student) || $reservation->student_id == Auth::user()->id) {//ensure the student or admin is responsible for this action
            $reservation->cancelReservation();
        }
        if (Auth::user() instanceof Student) {
            return redirect(route('accommodation.reservation'));
        } else {
            return redirect(route('accommodation.admin.backendreservation', ['studentid' => $student->id]));
        }
    }

    /* ADMIN */

    public function revokeAccommodation(Request $request, $reservationid)
    {
        //var_dump($id); exit();
        $user = Auth::user();
        $permission = "accommodation.admin.revokeaccommodation";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        $reservation = Reservation::findOrFail($reservationid);
        $student = $reservation->student;
        if (!in_array(self::checkEligibility($student, true), ['paid', 'claimed', 'waived'])) {
            return redirect(route('accommodation.admin.backendreservation', ['studentid' => $student->id]));
        }

        $result = $reservation->revokeReservation();

        return redirect(route('accommodation.admin.backendreservation', ['student_id' => $student->id]));
    }

    public function getStudentDetails(Request $request)
    {
        try {
            $user = Auth::user();
            $permission = "accommodation.admin.getstudentdetails";
            if (!$this->access($user,$permission))
                return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

            $regno = $request->query->get('regno');
//        return $request;
            $student = Student::where("matric_number","=",$regno)->first();
            if (!$student) {
                return response()->json([],501);
            }
            $accommodation = Accommodation::orderBy('id', 'desc')->first();
            $reservation = Reservation::where([['session', $accommodation->session], ['student_id', $student->id]])->whereIn('status', ['reserved', 'paid', 'claimed', 'waived'])->orderBy('id', 'DESC')->first();
            //var_dump(self::checkEligibility($student, true)); exit();
//        return $student;
            return view('pages.staff.accommodation.accommodation.studentdetails', array('student' => $student, 'reservation' => $reservation, 'eligibility' => self::checkEligibility($student, true), 'isadmin' => true));
        }catch (\Exception $e){
            return $e->getMessage();
        }
    }

    public function backendAccommodationProcess(Request $request)
    {
        $user = Auth::user();
        $permission = "accommodation.admin.backendaccommodationprocess";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        return view('pages.staff.accommodation.accommodation.backendaccommodationprocess');
    }

    /* public function relocateStudent(Request $request, $reservationid) {

      $reservation = Reservation::findOrFail($reservationid);
      $student = $reservation->student;


      $eligibility = self::checkEligibility($student, true);
      if(!in_array($eligibility,['paid','claimed','waived'])){
      return redirect(route('accommodation.admin.backendreservation', ['studentid' => $student->id]));
      }

      } */

    public function backendReservation(Request $request, $studentid)
    {

        $user = Auth::user();
        $permission = "accommodation.admin.backendreservation";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        $student = Student::findOrFail($studentid);
        $isadmin = false;
        if (!Auth::user() instanceof Student) {
            $isadmin = true;
        }
        $eligibility = self::checkEligibility($student, true);
        $accommodation = Accommodation::where('status', '<>', 'terminated')->orderBy('id', 'desc')->first();
        if (in_array($eligibility, ['reserved', 'paid', 'claimed', 'waived'])) {
            $reservation = Reservation::where([
                ['student_id', $student->id],
                ['session', $accommodation->session]
            ])
                ->whereIn('status', ['reserved', 'paid', 'claimed', 'waived'])
                ->first();
            $paidbutexpiredres = Reservation::getPaidButExpiredReservations($student, $reservation->session);
            return view('pages.staff.accommodation.reservation.reserved', array('student' => $student, "paidbutexpired" => $paidbutexpiredres->count(), 'reservation' => $reservation, 'isadmin' => $isadmin));
        } /* else if (in_array($eligibility, ['spillover', 'invalid_programme', 'part-time', 'defered', 'expelled', 'suspended', 'graduated'])) {
          return view('pages.student.accommodation.reservation.notentitled',['reason'=>$reason]);
          } else if (in_array($eligibility, ['notregistered', 'notpaid', 'nobiodata'])) {
          return view('pages.admin.accommodation.reservation.notentitled',['reason'=>$reason]);
          }
         */
        $hostels = Accommodation::getReservableHostel($student, true);
        return view('pages.staff.accommodation.reservation.backendreservation', array('hostels' => $hostels, 'student' => $student));
    }

    public function accommodationAction(Request $request)
    {
        $user = Auth::user();
        $permission = "accommodation.admin.accommodationaction";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        $hasroomconfig = true;
        $currentacc = Accommodation::where('status', '<>', 'terminated')->orderBy('id', 'desc')->first();
        if ($currentacc) {
            $roomconfigcount = RoomConfig::where('session', $currentacc->session)->count();
            if ($roomconfigcount == 0) {
                $hasroomconfig = false;
            }
        } else {
            $hasroomconfig = false;
        }
        $accommodations = Accommodation::where('status', 'terminated')->orderBy('id', 'desc')->limit(5)->get();
        return view('pages.staff.accommodation.accommodation.accommodationaction', ['accommodations' => $accommodations, 'currentacc' => $currentacc, 'hasroomconfig' => $hasroomconfig]);
    }

    public function newAccommodation(Request $request)
    {
        $user = Auth::user();
        $permission = "accommodation.admin.newaccommodation";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        $currentacc = Accommodation::where('status', 'active')->orderBy('id', 'desc')->first();
        if ($currentacc) {
            return redirect(route('accommodation.admin.accommodationaction'));
        }
        $accommodations = Accommodation::where('status', '<>', 'active')->orderBy('id', 'desc')->limit(5)->get();
        return view('pages.staff.accommodation.accommodation.newaccsetting', ['accommodations' => $accommodations]);
    }

    public function store(Request $request)
    {
        //
        $user = Auth::user();
        $permission = "accommodation.admin.storeaccommodation";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        $validatedData = $request->validate([
            'session' => 'required|unique:accommodations,session',
            'effective_date' => 'required'
        ]);
        $previousacc = Accommodation::where('status', 'suspended')->get();
        foreach ($previousacc as $prev) {
            $prev->status = 'terminated';
            $prev->end_date = new \DateTime();
            $prev->save();
        }
        $accommodation = new Accommodation();
        $accommodation->session = $request->request->get('session');
        $accommodation->effective_date = new \DateTime($request->request->get('effective_date'));
        $accommodation->save();
        return redirect(route('accommodation.admin.accommodationaction'));
    }

    public function terminateAccommodation(Request $request)
    {
        $user = Auth::user();
        $permission = "accommodation.admin.terminateaccommodation";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        $currentacc = Accommodation::where('status', '<>', 'terminated')->orderBy('id', 'asc')->first();
        if ($currentacc) {
            $currentacc->status = 'terminated';
            $currentacc->end_date = new \DateTime();
            $currentacc->save();
            return true;
        }
        return false;
        //return redirect(route('accommodation.admin.accommodationaction'));
    }

    public function deleteAccommodation(Request $request)
    {
        $user = Auth::user();
        $permission = "accommodation.admin.deleteaccommodation";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        $currentacc = Accommodation::where('status', '<>', 'terminated')->orderBy('id', 'desc')->first();
        if ($currentacc) {
            $roomconfigcount = RoomConfig::where('session', $currentacc->session)->count();
            if ($roomconfigcount == 0) {
                $currentacc->delete();
            }
        }
        return redirect(route('accommodation.admin.accommodationaction'));
    }

    public function toggleAccommodationStatus(Request $request)
    {
        $user = Auth::user();
        $permission = "accommodation.admin.toggleaccstatus";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        $currentacc = Accommodation::where('end_date', null)->orderBy('id', 'desc')->first();
        if ($currentacc) {
            $currentacc->status = ($currentacc->status == 'suspended') ? ('active') : ('suspended');
            $currentacc->save();
        }
        return redirect(route('accommodation.admin.accommodationaction'));
    }

    /**
     * REPORTS
     */
    public function studentAccommodationStatus()
    {
        $user = Auth::user();
        $permission = "accommodation.admin.report.studentaccstatus";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        return view('pages.staff.accommodation.report.studentaccstatus');
    }

    public function getStudentAccommodationStatus(Request $request)
    {
        $user = Auth::user();
        $permission = "accommodation.admin.report.getstudentaccstatus";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        $regno = $request->query->get('regno');
        $student = Student::fromMatricNumber($regno);
        $accommodation = Accommodation::orderBy('id', 'desc')->first();
        $reservation = Reservation::where([['session', $accommodation->session], ['student_id', $student->id]])->whereIn('status', ['reserved', 'paid', 'claimed', 'waived'])->orderBy('id', 'DESC')->first();
        //var_dump($reservation); exit();
        return view('pages.staff.accommodation.report.accommodationstatus', array('student' => $student, 'reservation' => $reservation, 'eligibility' => self::checkEligibility($student, true)));
    }

    public function generalAccommodationReport(Request $request)
    {
        $user = Auth::user();
        $permission = "accommodation.admin.report.generalaccreport";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        $hostels = Hostel::all();
        return view('pages.staff.accommodation.report.generalaccreport', ['hostels' => $hostels]);
    }

    public function loadGeneralAccommodationReport(Request $request)
    {
        $user = Auth::user();
        $permission = "accommodation.admin.report.loadgeneralreport";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        $hostel = Hostel::findOrFail($request->query->get('hostel'));
        $block = $request->query->get('block');
        $blocks = array();
        if ($block == "") {
            $blocks = $hostel->blocks;
        } else {
            $blocks[] = Block::findOrFail($block);
        }
        return view('partialpages.accommodation.report.rooms', array('blocks' => $blocks));
    }


    public function configuration(Request $request)
    {
        $user = Auth::user();
        $permission = "accommodation.admin.config";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        $configs = AccommodationConfig::all();
        $campuses = Faculty::distinct('campus')->pluck('campus');
        $faculties = Faculty::all();
        $departments = Department::all();
        $programe_modes = ProgrammeType::distinct('prog_type_code')->orderBy('prog_type_code','ASC')->pluck('prog_type_code');

        // Create a hierarchy of configurations based on parent_id
        $configsWithHierarchy = $this->buildHierarchy($configs);
        return view('pages.staff.accommodation.config.index', compact('configsWithHierarchy','campuses','faculties','departments','programe_modes'));
    }


    private function buildHierarchy($configs)
    {
        $configHierarchy = [];
        $configMap = [];
        foreach ($configs as $config) {
            $configMap[$config->id] = $config;
        }

        foreach ($configs as $config) {
            if ($config->parent_id === null) {
                $configHierarchy[] = $this->getConfigWithChildren($config, $configMap);
            }
        }

        return $configHierarchy;
    }

    private function getConfigWithChildren($config, $configMap)
    {
        $children = [];
        foreach ($configMap as $childId => $child) {
            if ($child->parent_id == $config->id) {
                $children[] = $this->getConfigWithChildren($child, $configMap);
            }
        }

        $config->children = $children;

        return $config;
    }

    public function configurationSave(Request $request){

        $user = Auth::user();
        $permission = "accommodation.admin.config";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));


        $config = new AccommodationConfig;
        $config->type = $request->type;
        $config->campus = $request->campus;
        $config->faculty_id = $request->faculty_id;
        $config->department_id = $request->department_id;
        $config->programme_id = $request->programme_id;
        $config->mode_of_entry = $request->programme_mode;
        $config->level_id = $request->level_id;
        $config->is_active = $request->is_active;
        $config->save();

        return back();
    }

    public function saveConfigs(Request $request)
    {
        $hierarchy = json_decode($request->sorted_config_ids, true);
        $deletedIds = explode(',', $request->input('deleted_ids'));

        // Delete records from the database
        AccommodationConfig::whereIn('id', $deletedIds)->delete();

        // Update hierarchy as before
        $this->updateHierarchy($hierarchy, null);

        return redirect()->back()->with('success', 'Configuration hierarchy updated successfully!');
    }

    // Recursive function to update hierarchy in the database
    private function updateHierarchy(array $hierarchy, $parentId)
    {
        foreach ($hierarchy as $node) {
            // Update the parent_id of the current node
            $config = AccommodationConfig::find($node['id']);
            if ($config) {
                $config->parent_id = $parentId;
                $config->save();
            }

            // Recursively update the children
            if (!empty($node['children'])) {
                $this->updateHierarchy($node['children'], $config->id);
            }
        }
    }

    /**
     * Show the bulk reservation upload page.
     */
    public function bulkReservationForm()
    {
        return view('pages.staff.accommodation.reservation.bulkreservation');
    }

    public function downloadBulkReservationTemplate()
{
    return Excel::download(new ReservationTemplateExport, 'bulk_reservation_template.xlsx');
}

    /**
 * Parse & validate the uploaded file and redirect to preview.
 */
public function parseBulk(Request $request)
{
    $request->validate([
        'excel_file' => 'required|file|mimes:xlsx,xls,csv|max:10240'
    ]);

    $file = $request->file('excel_file');
    $path = $file->store('bulk_uploads');

    // Parse rows & validate
    $result = $this->bulkReservationService->parseAndValidate($path);

    $rows   = $result['rows'] ?? [];
    $errors = $result['errors'] ?? [];

    if ($rows instanceof \Illuminate\Support\Collection) {
        $rows = $rows->toArray();
    }
    if ($errors instanceof \Illuminate\Support\Collection) {
        $errors = $errors->toArray();
    }

    // Determine error file path (if errors exist)
    $errorFilePath = null;
    if (!empty($errors)) {
        $errorFileName = 'bulk_uploads/errors_' . time() . '.csv';
        $handle = fopen(Storage::path($errorFileName), 'w');

        // Write headers
        fputcsv($handle, ['Row', 'Error Message']);

        foreach ($errors as $rowIndex => $message) {
            fputcsv($handle, [$rowIndex, $message]);
        }
        fclose($handle);

        $errorFilePath = $errorFileName;
    }

    // Add notes/summary
    $totalRows = count($rows);
    $errorCount = count($errors);
    $successCount = $totalRows - $errorCount;
    $notes = "{$successCount} reservations passed validation, {$errorCount} failed.";

    // Save log entry
    $log = BulkReservationLog::create([
        'file_name'       => $file->getClientOriginalName(),
        'uploaded_by'     => Auth::user()->username,
        'total_rows'      => $totalRows,
        'success_count'   => $successCount,
        'error_count'     => $errorCount,
        'tmp_path'        => $path,
        'rows'            => $rows,     // cast â†’ json
        'errors'          => $errors,   // cast â†’ json
        'error_file_path' => $errorFilePath,
        'notes'           => $notes,
    ]);

    return redirect()->route('accommodation.bulk.preview', $log->id);
}

public function downloadErrorFile(BulkReservationLog $log)
{
    if (!$log->error_file_path || !Storage::exists($log->error_file_path)) {
        return redirect()->back()->with('error', 'No error file available for this log.');
    }

    return Storage::download($log->error_file_path, 'failed_rows.csv');
}


/**
 * Display preview page for a given log.
 */
public function showPreview(BulkReservationLog $log)
{
     $rows   = $log->rows ?? [];
    $errors = $log->errors ?? [];

    return view('pages.staff.accommodation.reservation.preview', [
        'rows'            => $rows,
        'errors'          => $errors,
        'log'             => $log,
        'tmp_path'        => $log->tmp_path,
        'error_file_path' => $log->error_file_path, // ðŸ‘ˆ add this
    ]);
}


/**
 * Process (commit) the validated bulk reservations.
 */
public function processBulk(Request $request)
{
   
    $request->merge([
        'allow_partial' => $request->has('allow_partial') ? 1 : 0,
    ]);

    $request->validate([
        'log_id'        => 'required|exists:bulk_reservation_logs,id',
        'tmp_path'      => 'required|string',
        'allow_partial' => 'boolean',
    ]);

 //dd(Auth::user()->username);
    $log = BulkReservationLog::findOrFail($request->log_id);
 $isadmin = true;
 //dd($request->tmp_path);
    // process file
    $summary = $this->bulkReservationService->processFile(
        $request->tmp_path,
        $isadmin,
        $request->boolean('allow_partial', true)
    );

    //dd($summary);
    // update log
    $log->update([
        'success_count'  => $summary['success_count'],
        'error_count'    => $summary['error_count'],
        'error_file_path'=> $summary['error_file_path'],
        'notes'          => $summary['notes'] ?? null,
    ]);
 
    return view('pages.staff.accommodation.reservation.result', compact('summary'));
}

    public function viewLog($id)
    {
        $log = BulkReservationLog::findOrFail($id);
        return view('pages.staff.accommodation.reservation.log', compact('log'));
    }

   
public function expireSelected(Request $request)
{
    $request->validate([
        'reservation_ids' => 'required|array|min:1'
    ]);

    return DB::transaction(function () use ($request) {
        $now = now()->format('Y-m-d H:i:s');

        // Step 1: Fetch reservations to be expired
        $affectedReservations = Reservation::whereIn('id', $request->reservation_ids)
            ->where('status', '!=', 'expired')
            ->get(['id', 'room_config_id', 'student_id']);

            /*
        Log::debug('Reservations fetched for expiry', [
            'reservation_ids' => $affectedReservations->pluck('id')->toArray(),
            'roomconfig_ids'  => $affectedReservations->pluck('room_config_id')->toArray()
        ]);
*/
        if ($affectedReservations->isEmpty()) {
            Log::debug('No reservations found to expire');
            return redirect()->back()->with('info', 'No reservations were updated because they were already expired.');
        }

        $reservationIds = $affectedReservations->pluck('id')->toArray();
        $roomConfigIds  = $affectedReservations->pluck('room_config_id')->unique()->toArray();

        // Step 2: Expire reservations
        $updated = Reservation::whereIn('id', $reservationIds)
            ->update([
                'status'     => 'expired',
                'updated_at' => $now,
            ]);

        //Log::debug("Reservations expired", ['count' => $updated]);

        // Step 3: Check current occupants BEFORE update
        
        $beforeOccupants = DB::table('room_configs')
            ->whereIn('id', $roomConfigIds)
            ->pluck('occupied', 'id')
            ->toArray();

        //Log::debug('Occupants before update', $beforeOccupants);

        // Step 4: Calculate decrements per roomconfig
        $decrementCounts = $affectedReservations
            ->groupBy('room_config_id')
            ->map(fn($group) => $group->count());

        //Log::debug('Decrement counts per room', $decrementCounts->toArray());

        // Step 5: Update occupants per roomconfig
        foreach ($decrementCounts as $roomConfigId => $decrement) {
            $affected = DB::table('room_configs')
                ->where('id', $roomConfigId)
                ->update([
                    'occupied' => DB::raw("GREATEST(occupied - {$decrement}, 0)")
                ]);

            $after = DB::table('room_configs')
                ->where('id', $roomConfigId)
                ->value('occupied');
/*
                Log::debug("RoomConfig {$roomConfigId} update result", [
                'decrement' => $decrement,
                'affected_rows' => $affected,
                'before' => $beforeOccupants[$roomConfigId] ?? null,
                'after'  => $after
            ]);
            */
        }

        return redirect()->back()->with('success', 'Selected reservations expired successfully.');
    });
}


    public function expirereservationlist(Request $request)
    {
         $students = array();
        $user = Auth::user();
        $permission = "accommodation.admin.report.studentaccstatus";
        if (!$this->access($user,$permission))
            return view("pages.errors.nopermission", array("message" => "You have no permission to do this operation"));

        if ($request->ajax()) {
            try {
                $hostel_id = $request->input('hostel');
                $block_id = $request->input('block');
                $room_id = $request->input('room');
                $session = $request->input('session');

                // Validate dropdown values (must be numeric ID or '%')
                foreach (['hostel' => $hostel_id, 'block' => $block_id, 'room' => $room_id] as $key => $value) {
                    if (!is_null($value) && $value !== '%' && !is_numeric($value)) {
                        return response()->json([
                            'error' => "Invalid value for $key."
                        ], 422);
                    }
                }

                /*
                if (!is_null($status) && $status !== '%' && !in_array($status, ['reserved', 'occupied', 'cancelled'])) {
                    return response()->json([
                        'error' => "Invalid reservation status."
                    ], 422);
                }
               */
              
                // Query
                $reservations = Reservation::query()
                    ->join('students', 'reservations.student_id', '=', 'students.id')
                    ->leftJoin('room_configs', 'reservations.room_config_id', '=', 'room_configs.id')
                    ->join('rooms', 'room_configs.room_id', '=', 'rooms.id')
                    ->join('blocks', 'rooms.block_id', '=', 'blocks.id')
                    ->join('hostels', 'blocks.hostel_id', '=', 'hostels.id')
                    ->select(
                        'reservations.*',
                        'students.matric_number',
                        'students.firstname',
                        'students.surname',
                        'hostels.name as hostel_name',
                        'blocks.name as block_name',
                        'rooms.room_no as room_name',
                        'reservations.reserved_by',
                        'reservations.reservation_date',
                        'reservations.expiry_date'
                    );

                if ($hostel_id !== '%') {
                    $reservations->where('hostels.id', $hostel_id);
                }

                if ($block_id !== '%') {
                    $reservations->where('blocks.id', $block_id);
                }

                if ($room_id !== '%') {
                    $reservations->where('rooms.id', $room_id);
                }

                if (!empty($session)) {
                    $reservations->where('reservations.session', $session);
                }

                $reservations->where('reservations.status', 'reserved')
                ->where('expiry_date', '<', Carbon::now()->format('Y-m-d H:i:s'));

                $reservations->orderBy('hostels.name')
                            ->orderBy('blocks.name')
                            ->orderBy('rooms.room_no');

                $reservations = $reservations->get();

               // dd($reservations);

                return view('pages.staff.accommodation.reservation.load_expirereservation_data', compact('reservations', 'session'));

            } catch (\Exception $e) {
                Log::error('Room Occupancy Report Error: ' . $e->getMessage());
                return response()->view('errors.500', [], 500);
            }
        }

        return view('pages.staff.accommodation.reservation.expirereservation', compact('students'));
    }

    public function downloadErrors($id)
{
    $log = BulkReservationLog::findOrFail($id);

    if (!$log->error_file_path || !Storage::exists("app/bulk_results/{$log->error_file_path}")) {
        abort(404, "Error file not found.");
    }

    return response()->download(storage_path("app/bulk_results/{$log->error_file_path}"));
}

public function downloadAudit($id)
{
    $log = BulkReservationLog::findOrFail($id);

    if (!$log->audit_file_path || !Storage::exists("app/bulk_results/{$log->audit_file_path}")) {
        abort(404, "Audit file not found.");
    }

    return response()->download(storage_path("app/bulk_results/{$log->audit_file_path}"));
}

 
}