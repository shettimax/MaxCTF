<?php

namespace App\Services;

use App\Models\Accommodation;
use App\Models\Hostel;
use App\Models\Block;
use App\Models\Room;
use App\Models\RoomConfig;
use App\Models\Student;
use App\Models\Reservation;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use PhpOffice\PhpSpreadsheet\IOFactory;
use ZipArchive;
use Illuminate\Support\Facades\DB;

class BulkReservationService
{
    /**
     * Parse and validate the uploaded Excel file
     */
    public function parseAndValidate(string $storagePath)
{
    $fullPath = Storage::path($storagePath);
    $reader = IOFactory::createReaderForFile($fullPath);
    $spreadsheet = $reader->load($fullPath);
    $sheet = $spreadsheet->getActiveSheet();

    $rows   = [];
    $errors = [];

    $highestRow = $sheet->getHighestRow();
    $session    = $this->getCurrentAccommodationSession();

    for ($r = 2; $r <= $highestRow; $r++) {
        $reg    = trim((string) $sheet->getCell('A' . $r)->getValue());
        $hostel = trim((string) $sheet->getCell('B' . $r)->getValue());
        $block  = trim((string) $sheet->getCell('C' . $r)->getValue());
        $room   = trim((string) $sheet->getCell('D' . $r)->getValue());

        // Skip empty rows
        if ($reg === '' && $hostel === '' && $block === '' && $room === '') {
            continue;
        }

        $rowIndex = $r;
        $row      = compact('reg', 'hostel', 'block', 'room', 'rowIndex');
        $rows[]   = $row;

        // --- Validation checks ---
        if ($reg === '') {
            $errors[$rowIndex] = "Missing registration number";
            continue;
        }

        $student = Student::where('matric_number', $reg)->first();
        if (!$student) {
            $errors[$rowIndex] = "Registration number not found";
            continue;
        }

        $reservation = Reservation::where([
                        ['student_id', $student->id],
                        ['session', $session]])
                    ->whereIn('status', ['reserved', 'paid', 'claimed'])
                    ->first();
        if ($reservation) {
            $errors[$rowIndex] = " '$reg' had reservation";
            continue;
        }
            
        $hostelObj = Hostel::where('name', $hostel)->first();
        if (!$hostelObj) {
            $errors[$rowIndex] = "Hostel '$hostel' not found";
            continue;
        }

        $blockObj = Block::where('name', $block)
            ->where('hostel_id', $hostelObj->id)
            ->first();
        if (!$blockObj) {
            $errors[$rowIndex] = "Block '$block' not found in hostel '$hostel'";
            continue;
        }

        if ($room !== '') {
            $roomObj = Room::where('block_id', $blockObj->id)
                ->where('room_no', $room)
                ->first();

            if (!$roomObj) {
                $errors[$rowIndex] = "Room '$room' not found in block '$block'";
                continue;
            }

            if ($this->isRoomFull($roomObj, $session)) {
                $errors[$rowIndex] = "Room '$room' is already full/occupied";
                continue;
            }
        }
    }

    // --- Build error file if needed ---
    $errorFilePath = null;
    if (count($errors)) {
        $failedRows = [];
        foreach ($errors as $rowIndex => $msg) {
            $failedRows[] = [
                'row_index' => $rowIndex,
                'reg'       => $sheet->getCell('A' . $rowIndex)->getValue(),
                'hostel'    => $sheet->getCell('B' . $rowIndex)->getValue(),
                'block'     => $sheet->getCell('C' . $rowIndex)->getValue(),
                'room'      => $sheet->getCell('D' . $rowIndex)->getValue(),
                'error'     => $msg,
            ];
        }

        // Save failed rows to CSV in storage
        $errorFileName = 'bulk_uploads/errors_' . time() . '.csv';
        $handle = fopen(Storage::path($errorFileName), 'w');
        fputcsv($handle, ['Row', 'Reg No', 'Hostel', 'Block', 'Room', 'Error']);
        foreach ($failedRows as $fail) {
            fputcsv($handle, $fail);
        }
        fclose($handle);

        $errorFilePath = $errorFileName;
    }

    // --- Summary Notes ---
    $total   = count($rows);
    $errorCt = count($errors);
    $validCt = $total - $errorCt;

    $notes = "{$total} rows parsed. {$validCt} valid, {$errorCt} error(s).";
    if ($errorCt > 0) {
        $notes .= " Errors saved to file.";
    }

    return [
        'total'          => $total,
        'rows'           => $rows,
        'errors'         => $errors,
        'error_file_path'=> $errorFilePath,
        'notes'          => $notes,
        'success_count'  => $validCt,
        'error_count'    => $errorCt,
    ];
}


    public function processFile($filePath, $isadmin = false, $allowPartial = false)
{
    $filePath = storage_path('app/' . $filePath);

    if (!file_exists($filePath)) {
        throw new \Exception("File not found at: " . $filePath);
    }

    $errors      = [];
    $failedRows  = [];
    $auditRows   = [];
    $successCount = 0;
    $errorCount   = 0;
    $reservedBy   = Auth::user()->username ?? 'unknown';
    $session      = $this->getCurrentAccommodationSession();

    if (!$session) {
        return [
            'success_count'   => 0,
            'error_count'     => 0,
            'error_file_path' => null,
            'audit_file_path' => null,
            'notes'           => 'No active accommodation session',
        ];
    }

    // Load Excel
    $spreadsheet = \PhpOffice\PhpSpreadsheet\IOFactory::load($filePath);
    $worksheet   = $spreadsheet->getActiveSheet();
    $data        = $worksheet->toArray();

    $allSuccess = true;

    if (!$allowPartial) {
        DB::beginTransaction();
    }

    foreach ($data as $rowIndex => $row) {
        if ($rowIndex === 0) continue; // skip header row

        $matric = trim($row[0] ?? '');
        $hostel = trim($row[1] ?? '');
        $block  = trim($row[2] ?? '');
        $roomNo = trim($row[3] ?? ''); // optional

        try {
            // Basic validation
            if (!$matric || !$hostel || !$block) {
                throw new \Exception("Matric, Hostel and Block are required (row {$rowIndex})");
            }

            $student = Student::where('matric_number', $matric)->first();
            if (!$student) {
                throw new \Exception("Student with matric no {$matric} not found.");
            }

            // If room number is supplied → use it
            if ($roomNo) {
                $room = Room::whereHas('block', function ($q) use ($hostel, $block) {
                            $q->where('name', $block)
                              ->whereHas('hostel', fn($h) => $h->where('name', $hostel));
                        })
                        ->where('room_no', $roomNo)
                        ->first();

                if (!$room) {
                    throw new \Exception("Room {$hostel} {$block} {$roomNo} not found.");
                }

                $roomConfig = RoomConfig::where('room_id', $room->id)
                    ->where('session', $session)
                    ->first();

                if (!$roomConfig) {
                    throw new \Exception("No RoomConfig found for room {$hostel} {$block} {$roomNo}.");
                }
            } 
            // Otherwise pick next available room in the block
            else {
                $blockObj = Block::where('name', $block)
                    ->whereHas('hostel', fn($h) => $h->where('name', $hostel))
                    ->first();

                if (!$blockObj) {
                    throw new \Exception("Block {$block} in {$hostel} not found.");
                }

                $roomConfig = RoomConfig::whereHas('room', fn($q) => $q->where('block_id', $blockObj->id))
                                ->where('session', $session)
                                ->whereColumn('occupied', '<', 'bed_space')
                                ->orderBy('room_id', 'asc')
                                ->first();

                if (!$roomConfig) {
                    throw new \Exception("No available room found in block {$block} ({$hostel}).");
                }

                $roomNo = $roomConfig->room->room_no ?? 'AUTO';
            }

            // Try reservation
            $result = Reservation::reserve($roomConfig, $student, $isadmin);

            if ($result !== 'success') {
                throw new \Exception("Reservation failed: {$result}");
            }

            $successCount++;

            $auditRows[] = [$matric, $hostel, $block, $roomNo, 'SUCCESS', ''];

        } catch (\Exception $e) {
            $allSuccess = false;
            $errors[$rowIndex] = $e->getMessage();
            $failedRows[] = $row;
            $errorCount++;

            $auditRows[] = [$matric, $hostel, $block, $roomNo ?: 'AUTO', 'FAILED', $e->getMessage()];

            if (!$allowPartial) {
                DB::rollBack();
                unlink($filePath);

                return [
                    'success_count'   => 0,
                    'error_count'     => count($data) - 1, // all except header
                    'error_file_path' => null,
                    'audit_file_path' => null,
                    'notes'           => 'Bulk reservation failed. No records committed.',
                ];
            }
        }
    }

    if (!$allowPartial && $allSuccess) {
        DB::commit();
    }

    $resultsDir = storage_path('app/bulk_results');

// Create directory if it doesn’t exist
if (!file_exists($resultsDir)) {
    mkdir($resultsDir, 0777, true);
}
    // Prepare output CSVs
    $failedCsvPath = null;
    $auditCsvPath  = null;

    if ($errorCount > 0) {
        // Failed rows CSV
        $failedCsvFile = 'failed_reservations_' . time() . '.csv';
        $failedCsvPath = $resultsDir . '/' . $failedCsvFile;
        $fp1 = fopen($failedCsvPath, 'w');
        foreach ($failedRows as $failedRow) {
            fputcsv($fp1, $failedRow);
        }
        fclose($fp1);
    }

    // Audit CSV (always generated)
    $auditCsvFile = 'audit_reservations_' . time() . '.csv';
    $auditCsvPath = $resultsDir . '/' . $auditCsvFile;
    $fp2 = fopen($auditCsvPath, 'w');
    fputcsv($fp2, ['Matric No', 'Hostel', 'Block', 'Room No', 'Status', 'Error Message']);
    foreach ($auditRows as $auditRow) {
        fputcsv($fp2, $auditRow);
    }
    fclose($fp2);

    // cleanup uploaded Excel
    unlink($filePath);

    // Always return consistent array
    return [
        'success_count'   => $successCount,
        'error_count'     => $errorCount,
        'error_file_path' => $failedCsvPath,
        'audit_file_path' => $auditCsvPath,
        'notes'           => $errorCount > 0
            ? 'Bulk reservation completed with some failures.'
            : 'All reservations processed successfully.',
    ];
}


    /**
     * Bulk revert reservations with CSV+ZIP export
     */
    public function bulkRevert(array $rows)
    {
        $session = $this->getCurrentAccommodationSession();
        $failed = [];

        foreach ($rows as $row) {
            $student = Student::where('matric_number', $row['reg'])->first();
            if (!$student) {
                $failed[] = $row + ['reason' => 'Student not found'];
                continue;
            }

            $reservation = Reservation::where('student_id', $student->id)
                ->where('session', $session)
                ->first();

            if (!$reservation) {
                $failed[] = $row + ['reason' => 'Reservation not found'];
                continue;
            }

            $reservation->delete();
        }

        if (!empty($failed)) {
            $csvPath = storage_path('app/failed_reverts.csv');
            $zipPath = storage_path('app/failed_reverts.zip');

            $handle = fopen($csvPath, 'w');
            fputcsv($handle, ['Matric No', 'Hostel', 'Block', 'Room No', 'Reason']);
            foreach ($failed as $f) {
                fputcsv($handle, [$f['reg'], $f['hostel'], $f['block'], $f['room'], $f['reason']]);
            }
            fclose($handle);

            $zip = new ZipArchive;
            if ($zip->open($zipPath, ZipArchive::CREATE) === true) {
                $zip->addFile($csvPath, 'failed_reverts.csv');
                $zip->close();
            }

            return response()->download($zipPath)->deleteFileAfterSend(true);
        }

        return ['status' => 'success'];
    }

    /**
     * Get current accommodation session
     */
    protected function getCurrentAccommodationSession()
    {
        $accommodation = Accommodation::whereNull('end_date')->orderByDesc('id')->first();
        return $accommodation ? $accommodation->session : null;
    }

    /**
     * Check if a room is full for a session
     */
    protected function isRoomFull($room, $session)
    {
        if (!$room) return true;

        $roomConfig = RoomConfig::where('room_id', $room->id)
            ->where('session', $session)
            ->first();

        if (!$roomConfig) return true;

        return $roomConfig->occupied >= $roomConfig->bed_space;
    }

}