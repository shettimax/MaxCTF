<?php

namespace App\Models;

use Carbon\Carbon;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Support\Facades\DB;

class Student extends Authenticatable
{

    use Notifiable;

    public function coursegroups()
    {
        $param = func_get_args();
        if (count($param) == 0) {
            return $this->belongsToMany(CourseGroup::class, 'course_registrations');
        } elseif (count($param) == 1) {
            $session = $param[0];
            return $this->belongsToMany(CourseGroup::class, 'course_registrations')->where(['course_groups.session' => $session]);
        } elseif (count($param) == 2) {
            $session = $param[0];
            $semester = $param[1];
            return $this->belongsToMany(CourseGroup::class, 'course_registrations')->where(['course_groups.session' => $session, 'course_groups.semester' => $semester]);
        } elseif (count($param) == 3) {
            $session = $param[0];
            $semester = $param[1];
            $course_group_ids = $param[2];
            return $this->belongsToMany(CourseGroup::class, 'course_registrations')->where(['course_groups.session' => $session, 'course_groups.semester' => $semester])->whereIn('id', $course_group_ids);
        }
    }

    protected $guarded = [
        'matricnumber', 'password',
    ];

    /**
     * The attributes that should be hidden for arrays.
     *
     * @var array
     */
    protected $hidden = [
        'password', 'remember_token',
    ];

    public static function fromMatricNumber($matricnumber)
    {
        return Student::where(['matric_number' => $matricnumber])->first();
    }

    public function getFullName()
    {
        return $this->surname . ", " . $this->firstname . " " . $this->other_names;
    }

    public static function iDCardName($id)
    {
        $student = Student::find($id);

        $nameLength = strlen(trim($student->surname)) + strlen(trim($student->firstname)) + strlen(trim($student->other_names)) + 2;

        $surname = ucfirst($student->surname);
        $firstname = ucfirst($student->firstname);
        $other_names = ucfirst($student->other_names);

        if ($nameLength >= 19) {
            $longest = strlen($student->surname);
            if (strlen($student->firstname) > $longest) {
                $firstname = $firstname[0] . ".";
            } else if (strlen($student->other_names) > $longest) {
                $other_names = $other_names[0] . ".";
            } else {
                $surname = $surname[0] . ".";
            }

        }

        return ucwords(strtolower("$surname $firstname $other_names"));
    }

    /**
     * Gets the degree of a student.
     *
     * @return \App\Models\DegreePlan
     */
    public function getdegreeplan()
    {
        return $this->belongsTo(DegreePlan::class);
    }

    /**
     * Gets the Country of a student.
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
     */
    public function getcountry()
    {
        return $this->belongsTo(Country::class);
    }

    /**
     * Gets the LGA of a student.
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
     */
    public function getlga()
    {
        return $this->belongsTo(Lga::class);
    }

    /**
     * Gets the Programme of a student.
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
     */

    public function getprogramme()
    {
        return $this->belongsTo(Programme::class, 'programme_id');
    }

    /**
     * Gets the current Programme of a student.
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
     */
    public function programme()
    {
//        return $this->belongsTo(Programme::class);
        return Programme::find($this->programme_id);
    }

    /* public function programme1() {
         return $this->belongsTo(Programme::class, 'programme_id');
     }*/

    /**
     * Gets the current Department of a student.
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
     */
    public function department()
    {
        return Department::find($this->programme()->department_id);
    }

    /**
     * Gets the current Faculty of a student.
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
     */
    public function faculty()
    {
        return Faculty::find($this->department()->faculty_id);
    }

    /**
     * Gets the current Nationality of a student.
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
     */
    public function nationality()
    {
        return $this->belongsTo(Country::class, 'country_id')->first();
    }

    /**
     * Gets the current LGA of a student.
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
     */
    public function lga()
    {
        return Lga::find($this->lga_id);
    }

    public function state()
    {
        return State::find(Lga::find($this->lga()->id)->state_id);
    }

    /**
     * Tells if a student is new or old (true for new , false for old).
     *
     * @return boolean
     */
    public function isNew($session = null)
    {
        $sesRegCount = $this->sessionReg()->count();
        if($sesRegCount>1)
            return false;
        if (!$this->currentSession()) return true;
        $session = ($session == null) ? $this->currentSession()->session : $session;
        return $this->entry_session == $session ? true : false;//$currentSession->session:$this->entry_session;#true for new, false for returning and 0 for both
    }

    /**
     * Gets the current Session of a student from RegistrationPeriod (can be first or second semester).
     *
     * @param optional parameter semester , can be 1 or 2
     *
     * @return first instance of RegistrationPeriod sorted in DESC order by date
     */
    public function currentSession($semester = 1)
    {
        $sesReg = $this->sessionReg()->first();
        $regperiod = RegistrationPeriod::where([
            'programme_id' => $this->programme_id,
            'nature' => 'FEE',
            'new_returning' => $sesReg->session != $this->entry_session ? "Returning" : "new"
        ])
            ->whereDate('start_date', "<=", Carbon::now())
            ->where("session", ">=", $this->entry_session)
            // ->where("session", "=", 2023)
            ->orderBy("session", "DESC")
            ->orderBy('new_returning', 'DESC')->first();
        return $regperiod;
    }

    public function programeSession($session)
    {
        $regperiod = RegistrationPeriod::where(['programme_id' => $this->programme_id, 'nature' => 'FEE'])
//            ->whereDate('start_date', "<=", Carbon::now())
            ->where("session", ">", $session)
            ->orderBy("session", "ASC")
            ->orderBy('new_returning', 'DESC')->first();
        return $regperiod;
    }

    /**
     * Gets the programme of a given as at a given session , This change is possible in case of transfer students as their fees will vary
     *in their previous programme
     *
     * @param parameter session , must be numeric
     * @assumption Every student has only one record for each session in session_reg
     * @return  instance of Programme based on the id from the session_reg of a this student
     */
    public function sessionProgramme($session)
    {
        $ses_reg = SessionReg::where(["session" => $session, "student_id" => $this->id])->first();
        if ($ses_reg)
            return Programme::find($ses_reg->programme_id);
        return $this->programme();
    }

    public function level()
    {
        return Level::find($this->entry_level_id);
    }

    public function sessionLevel($session)
    {
        $ses_reg = SessionReg::where(["session" => $session, "student_id" => $this->id])->first();
        if ($ses_reg)
            return Level::find($ses_reg->level_id);
        return $this->level();
    }

    public function studyTypeIn($session, $format = 0)
    {
        $type = SessionReg::where(["session" => $session, "student_id" => $this->id])->first();
        if ($type) {
            $type = $type->studytype;
            if ($format) {

                switch ($type) {

                    case 'Others':
                        return 0;
                        break;
                    case 'Non Academic':
                        return 2;
                        break;
                    case 'Academic':
                        return 1;
                        break;
                    default:
                        return 0;
                        break;

                }
            }
            return $type;
        }
        return 3;
    }

    public function generateMatric()
    {
        if ($this->matric_gen == "yes")
            return false;
        $isPG = $this->isPGStudent();
        $entry_mode = substr($this->mode_of_entry, 0, 1);
        $programme = $this->programme();
        $department = $programme->department();
        $faculty = $department->faculty();
        $level = Level::find($this->entry_level_id);
        $sess_no = substr($this->entry_session, 2);
        $st1 = Student::where(['entry_session' => $this->entry_session, "programme_id" => $this->programme_id, "entry_level_id" => $this->entry_level_id, "matric_gen" => 'yes'])->orderBy('matric_number', 'DESC')->first();;
        $prog_count = 1;
        $code = $isPG ? $faculty->faculty_code . $department->dept_code : $programme->short_code;

        $sessionReg = SessionReg::where(["session" => $this->entry_session, "student_id" => $this->id])->first();
        do {
            $matric = $entry_mode . $sess_no . $code . ($level->number) . str_pad($prog_count, 3, "0", STR_PAD_LEFT);
            $prog_count++;
        } while (Student::where('matric_number', "=", $matric)->first());


        $this->matric_number = $matric;
//            $entry_mode . $sess_no .  $code . (Level::find($this->entry_level_id)->number) . str_pad($prog_count, 3, "0", STR_PAD_LEFT);
        $this->matric_gen = "yes";
        $this->save();

        if ($sessionReg) {
            $sessionReg->matric_number = $this->matric_number;
            $sessionReg->save();
        }
        return true;
    }

    public function cleanSessionRecords()
    {
        $allProgrammeSessions = RegistrationPeriod::where("session", ">=", $this->entry_session)->where(['programme_id' => $this->programme_id])->pluck('session')->toArray();

    }

    public function loginTask()
    {
        $this->initStudentLevel();
        $output = [];

        $studentSessionReg = $this->sessionReg()->first();
        if ($studentSessionReg->programme_id != $this->programme_id || $studentSessionReg->matric_number != $this->matric_number) {
            $studentSessionReg->programme_id = $this->programme_id;
            $studentSessionReg->matric_number = $this->matric_number;
            $studentSessionReg->save();
        }
        $output["graduated"] = $this->hasGraduated();
        $output["disciplinaryaction"] = $this->disciplinaryCases()->all();
        $output["overstayed"] = $this->hasOverStayed();

        return $output;
    }

    public function completedResidency($session = null)
//        4- (1-1) = 4- 0 = 4
//        4 -(2-1) = 4-1 = 3
    {

        $programme = Programme::find($this->programme_id);
        $level = Level::find($this->entry_level_id);
        $sessionRght = $programme->activeSession($level->id);

        if (AllowOverStay::where(['session' => $sessionRght, 'student_id' => $this->id])->first()) {
            return FALSE;
        }

        $where[] = ["session", ">=", $this->entry_session];
        $duration = $this->mode_of_entry == "PG" ? $programme->duration * 1.5 : ($programme->duration - ($level->number - 1)) * 1.5;
        if ($session) {
            $where[] = ["session", "<=", $session];
        }
        $sessionCount = SessionReg::where(['student_id' => $this->id])->where($where)->count();
        $sessionCount = count($this->residencySessions());

        return !($sessionCount < ($duration));

    }

    public function hasGraduated()
    {
        $sessReg = $this->sessionReg()->first();

        return $sessReg ? ($sessReg->graduation_status == "Graduated") : false;
    }

    public function setStudentPlan()
    {
        $degreeplan = $this->programme()->degreeplan();
        if ($this->degree_plan_id != $degreeplan->id) {
            $this->degree_plan_id = $degreeplan->id;
            $this->save();
        }
    }

    public function hasOverStayed()
    {
        $currentSession = $this->currentSession();
        $duration = $this->programme()->duration;
        if ($currentSession) {
            if (($currentSession->session - $this->entry_session) <= ($duration + $duration / 2)) {
                return 0;
            } else {

                $extention = DB::table("disciplines")->selectRaw("SUM(semester) AS duration")->where(["student_id" => $this->id])->first()->duration * 1;

                if ((isset($currentSession->session) ? $currentSession->session : $this->entry_session - $this->entry_session) <= ($duration + $duration / 2 + $extention / 2)) {
                    return 0;
                }

                if ($this->allowedOverstay()) {
                    return 0;
                }
            }
        } else {
            return 0;
        }


        return 1;
    }

    public function residencyExhausted()
    {
        $currentSession = $this->currentSession();
        $prg = $this->programme();
        $entryLevel = Level::find($this->entry_level_id);
//        $duration = $prg->duration;
        $duration = $this->mode_of_entry == "PG" ? $prg->duration * 1.5 : ($prg->duration - ($entryLevel->number - 1)) * 1.5;
        $durationstayed = count($this->residencySessions());//$currentSession->session - $this->entry_session;
//        $durationstayed = $period + $extention / 2;
        if ($durationstayed > $duration) {
            return true;
        }
        return false;
    }

    public function allowedOverstay()
    {
        $currentSession = $this->currentSession();
        return $this->hasMany(AllowOverStay::class)->where(["session" => isset($currentSession->session) ? $currentSession->session : $this->entry_session])->first() != null;
    }

    public function disciplinaryCases($session = null, $semester = null)
    {

        $case = Discipline::where(["student_id" => $this->id])->orderBy('end_session', "DESC")->orderBy('end_semester', "DESC");
        if ($session) {
            $case = $case->where(["session" => $session]);
            if ($semester)
                $case = $case->where(["semester" => $semester]);
            return $case->get();
        }
        return $case->get();
//                return $case = $case->whereRaw("(end_session > {$currentSession->session}) OR (end_session = {$currentSession->session} AND end_semester>{$currentSession->semester} )")->get();


        return [];
    }

    public function hasDisciplinaryCase($session = null)
    {
        return count($this->disciplinaryCases($session)) > 0;
    }

    /* public function isDefered()
      {
      return Discipline::where(["student_id"=>$this->id])->orWhere(["nature"=>"Deferment"])->orWhere(["nature"=>"Deferment"])->get();
      } */

    public function isDefered()
    {
        $disp = Discipline::where([["student_id", "$this->id"], ["nature", "Deferment"]])->get();
        return $disp->count() > 0;
    }

    public function initStudentLevel()
    {
        $resTed = $this->initReg();
        $currentSession = $this->currentSession();
        $studentSessionReg = $this->sessionReg()->first();
        $thisStudentLevel = null;

        if ($studentSessionReg)
            $thisStudentLevel = StudentLevel::where(["student_id" => $this->id, "session" => $studentSessionReg->session])->first();

        if (($resTed || $thisStudentLevel == null) && ($studentSessionReg->graduation_status != "Graduated")) {
            $studentlevel = new StudentLevel();
            $studentlevel->student_id = $this->id;
            $studentlevel->session = isset($studentSessionReg->session) ? $studentSessionReg->session : $this->entry_session;
            $studentlevel->semester = 1;
            $studentlevel->level_id = isset($studentSessionReg->level) ? $studentSessionReg->level : $this->entry_level_id;
            $studentlevel->programme_id = $this->programme_id;
            $studentlevel->save();
            $studentlevel = new StudentLevel();
            $studentlevel->student_id = $this->id;
            $studentlevel->session = isset($studentSessionReg->session) ? $studentSessionReg->session : $this->entry_session;
            $studentlevel->semester = 2;
            $studentlevel->level_id = isset($studentSessionReg->level_id) ? $studentSessionReg->level_id : $this->entry_level_id;
            $studentlevel->programme_id = $this->programme_id;
            $studentlevel->save();
        }
    }

    public function initReg()
    {
        $studentSession = $this->sessionReg()->first();
        if (!$studentSession) {// absolutely new student with never before entered sessionReg
            $maritalstatus = "Single";

            $sessionReg = new SessionReg();
            $sessionReg->student_id = $this->id;

            $sessionReg->matric_number = strtoupper($this->matric_number);
            $sessionReg->programme_id = $this->programme()->id;
            $sessionReg->session = $this->entry_session;
            $sessionReg->level_id = $this->entry_level_id;
            $sessionReg->graduation_status = "Not Graduated";
            $sessionReg->marital_status = $maritalstatus == "" ? "Single" : $maritalstatus;
            $sessionReg->study_mode = "Full Time";
            $sessionReg->study_type = "Others";
            $sessionReg->save();
            return true;
        } else {//Existing student loging in for 1st time in this session|| must atleast clear his previous session to move to next

            $currentSession = $this->programeSession($studentSession->session);
//            $currentSession = $this->currentSession();
            if ($currentSession) {
                if (($currentSession->session > $studentSession->session) && ($this->feesClearedForCurrentSession()) && $studentSession->graduation_status != "Graduated" && !$this->completedResidency()) {

                    $level = Level::find($studentSession->level_id);
                    $sessionReg = new SessionReg();
                    $sessionReg->student_id = $this->id;
                    $sessionReg->matric_number = strtoupper($this->matric_number);
                    $sessionReg->programme_id = $this->programme()->id;
                    $sessionReg->session = isset($currentSession->session) ? $currentSession->session : $this->entry_session + 1;
                    $sessionReg->level_id = $level->next($this->programme()->id)->id;
                    $sessionReg->graduation_status = "Not Graduated";
                    $sessionReg->marital_status = $studentSession->marital_status == "" ? "Single" : $studentSession->marital_status;
                    $sessionReg->study_mode = "Full Time";
                    $sessionReg->study_type = "Others";

                    $sessionReg->save();
                    return true;
                }
            }
        }
        return false;
    }

    public function payableSessions($type = 0)
    {
        $q = $payableSessions = SessionReg::where(["student_id" => $this->id])->orderBy('session', 'DESC');
        if ($type) return $q->get();
        return $q->pluck("session");
    }


    public function nextPayableSession()
    {
        return $this->programmeSession();
        foreach ($this->programmeSession() as $session) {
            if (!$this->feesClearedForSession($session))
                return $session;
        }
        return 0;
    }

    public function programmeSession()
    {
        return RegistrationPeriod::where('programme_id', $this->programme_id)
            ->where('session', ">=", $this->entry_session)
            ->orderBy("session", "ASC")
            ->groupBy("session")
            ->pluck('session');
    }

    /**
     * Gets the current SessionReg configuration of a student.
     *
     * @return SessionReg
     */
    public function sessionReg()
    {
        return SessionReg::where("student_id", $this->id)
//            $this->hasMany(SessionReg::class, 'student_id')
            ->orderBy('session', 'DESC');
    }

    public function highestPaidSession()
    {
        foreach ($this->sessionReg()->pluck('session') as $session) {
            if ($this->feesClearedForSession($session)) {
                return $session;
            }
        }

        return 0;
    }

    /**
     * Gets the current Semester of a student.
     *
     * @return RegistrationPeriod
     */
    public function currentSemester()
    {
        $currentsession = $this->currentSession();;
        if ($currentsession) {
            return $result = RegistrationPeriod::where(['programme_id' => $currentsession->programme_id, 'nature' => 'REG'])
                ->where([
                    "session" => $currentsession->session,
                    "new_returning" => $currentsession->new_returning
                ])
                ->whereDate('start_date', "<=", Carbon::now())
                ->orderBy("id", "DESC")
                ->orderBy('new_returning', 'DESC')->first();
        }
        return [];
    }

    /**
     * Checks if registration is open for everyone in students category
     *
     * @param semester can be specified to know what registration period is required
     *
     * @return boolean
     */
    public function isRegOpen($session, $date = null)
    {
        $date = ($date == null) ? Carbon::now() : $date;
        $ret = $this->isNew($session) ? "New" : "Returning";
        $sess = RegistrationPeriod::whereRaw('programme_id=' . $this->programme()->id . " AND session=" . $session . " AND nature='FEE' AND new_returning ='$ret' AND start_date <= CURRENT_DATE() AND late_start_date >= CURRENT_DATE()")
            ->first();
        if ($sess) {
            return $sess;
        }

        $sess = SpecialRegistrationPeriod::whereRaw('student_id=' . $this->id . " AND session=" . $session . " AND nature='FEE' AND start_date <= CURRENT_DATE() AND end_date >= CURRENT_DATE()")
            ->first();

        if ($sess) {
            return $sess;
        }

        return false;
    }

    /**
     * Checks if registration is open for $this student.
     *
     * @param semester can be specified to know what registration period is required
     *
     * @return boolean
     */
    public function specialRegistrationPeriod($session, $semester = 1)
    {
        $query = $this->hasMany(SpecialRegistrationPeriod::class, 'student_id')
            ->where(['session' => $session,
                'nature' => 'FEE', "semester" => $semester])->orderBy('id', 'DESC');
        if ($query->first()) {
            return today() <= $query->first()->late_start_date;

        }
        return false;
    }

    /**
     * Checks if $this student has paid any amount in the specified session and semester
     * This function is currently ony used for first semester
     *
     * @param session,semester can be specified
     *
     * @return boolean
     */
    public function hasPaidSomethingBeforeLatePeriodForSemester($session, $semester = 1)
    {

        $sessionreg = SessionReg::where(["session" => $session, "student_id" => $this->id])->first();
        $newreturning = $this->isNew() ? "New" : "Returning";
        $rec = RegistrationPeriod::where(['programme_id' => $this->programme()->id, "session" => $session, 'nature' => 'FEE', "semester" => $semester, "new_returning" => $newreturning, "level_id" => $sessionreg->level_id])
            ->whereDate('start_date', "<=", Carbon::now())->orderBy("id", "DESC")->first();
        if (!$rec) return false;
        $transaction = Transaction::where(["student_id" => $this->id, "code" => "REG", "session" => $session])
            ->whereDate("updated_at", "<=", $rec->late_start_date)
            ->whereIn("payment_status", ["Paid", "Waived"]);
        return $transaction->first() != null;
    }

    public function biodata()
    {
        return $this->hasOne(StudentBiodata::class, 'student_id')->first();
    }

    public function formTransactions()
    {
        $ids = CandidateForm::where(['candidate_forms.student_id' => $this->id])
            ->join("transactions", "transactions.student_id", "=", "candidate_forms.id")
            ->where("code", "=", "FRM")->pluck("transactions.id");
        return Transaction::whereIn("id", $ids)->get();
    }

    public function transactions($session, $type = "REG")
    {
        return Transaction::where(["student_id" => $this->id, "code" => $type, "session" => $session])->get();
    }

    public function lateReg($session, $date)
    {
        $now = \Carbon\Carbon::now();
        $start_point = \Carbon\Carbon::parse($date);

        $sessionreg = SessionReg::where(["session" => $session, "student_id" => $this->id])->first();

        if ($session >= 2019) {
            if ($now < $start_point) return 0;
            $tr = Transaction::whereRaw("student_id ={$this->id} AND code='REG' AND session={$session} AND payment_status='Paid' AND payment_date<='$date'")->first();
            if ($tr) {
                return 0;
            }
            return 1;


        } else {
            $tr = Transaction::where(["student_id" => $this->id, "code" => 'REG', "session" => $session, "payment_status" => "Paid"])
                ->first();
            if ($tr) {
                return 0;
            }
            return 1;
        }
    }

    public function sessionFees($session)
    {
//        $session = $session == 0? $this->currentSession()->session:$session;
//        [ "fees"=>$fees,"total"=>$amount,"amountpaid"=>$paid,"percentage"=>$percentage,"transaction"=>$transactions ,"waived"=>$waived]
        $feemanager = new FeeManager();
        return $feemanager->computeFee($this, $session);
    }

    public function feesClearedForCurrentSession()
    {

        return $this->feesClearedForSession($this->sessionReg()->first()->session);
    }

    public function feesClearedForSession($session)
    {
        $fees = $this->sessionFees($session);
//        unset($fees["fees"]);
        if (!empty($fees) && is_array($fees)) {
            if ($fees["percentage"] >= 100) {
                return true;
            }
        }
        return false;
    }

    public static $menu = [
        "Biodata" => "profile.index",
    ];
    public static $passwordrules = [
        "currentpassword" => "required|min:6",
        "newpassword" => "required|min:6|confirmed"
    ];

    public function status($session = null)
    {
        $current = $this->currentSemester();
        if (!$session) {
            $session = $current->session;
            $semester = $current->semester;
        }

        $sessionReg = $this->sessionReg()->where(["session" => $session])->first();
        if ($this->hasGraduated()) {
            return (object)["code" => 1, "status" => "Graduated", "color" => "green"];
        } else {

            if (isset($semester))
                $disciplinaryCase = $this->disciplinaryCases($session, $semester);
            else
                $disciplinaryCase = $this->disciplinaryCases($session);

            if (count($disciplinaryCase)) {
                $nature = $disciplinaryCase[0]->nature;
                switch ($nature) {
                    case "Suspension":
                    case "Warning":
                        $code = 0;
                        $color = "orange";
                        break;
                    case "Expulsion":
                    case "Rustication":
                    case "Withdrawal of Admission":
                    case "Revocation":
                        $code = -1;
                        $color = "red";
                        break;
                }
                return (object)["code" => $code, "status" => $nature, "color" => $color];
            } else {
                return (object)["code" => 1, "status" => "Active", "color" => "green"];
            }
        }
    }

    public function courseRegistration($where = [])
    {
        $cr = CourseRegistration::where(["student_id" => $this->id]);
        return count($where) ? $cr->where($where) : $cr;
    }

    public function hasRespondedTo($course_group_id, $course_lecturer_id)
    {
        return SetResponse::where(["course_lecturer_id" => $course_lecturer_id, "course_group_id" => $course_group_id, "student_id" => $this->id])->count() > 0;
    }

    public function conditionalMessage()
    {
        $cm = StudentConditionalMessage::where("student_id", "=", $this->id)->first();
        if (!$cm) {
            $cm = new StudentConditionalMessage;
            $cm->student_id = $this->id;
            $cm->answered_messages = "";
            $cm->seen_messages = "";
            $cm->save();
        }

        return $cm;
    }


    public static function photo2Base64($matricNumber)
    {
        $matric = str_replace("/", "_", strtoupper($matricNumber));
        if (file_exists(public_path() . '/studentpics/' . $matric . '.JPG')) {
            $pathToFile = public_path() . "/studentpics/" . $matric . ".JPG";
            $type = pathinfo($pathToFile, PATHINFO_EXTENSION);
            $data = file_get_contents($pathToFile);
            return str_replace("\/", "/", base64_encode($data));
        } else {
            return "";
        }
    }

    public function hasWallet()
    {
        return $this->wallet_number ? true : false;
    }

    public function courseRegistrationOpen($session, $semester)
    {
        $sessionReg = SessionReg::where(["student_id" => $this->id, "session" => $session])->first();
        if ($sessionReg) {
            $reg = RegistrationPeriod::where([
                "session" => $session, "semester" => $semester, "nature" => "REG",
                "level_id" => $sessionReg->level_id, "new_returning" => $this->isNew($session) ? "New" : "Returning",
                "programme_id" => $sessionReg->programme_id
            ])->whereRaw("(end_date>='" . today() . "' OR add_end_date>='" . today() . "')")->first();
            if ($reg) {
                return true;
            } else {
                $reg2 = SpecialRegistrationPeriod::where([
                    "session" => $session, "semester" => $semester, "nature" => "REG",
                    "student_id" => $this->id
                ])->whereRaw("end_date>='" . today() . "'")->first();
                return $reg2 ? true : false;
            }

        }

        return false;
    }

    public function courseRegLogs()
    {
        $cls = CourseRegLog::where(["student_id" => $this->id])->get();
        $sessionRecs = [];

        foreach ($cls as $cl) {
            $sessionRecs[$cl->session . "-" . $cl->semester] = $cl->logs;
        }

        return $sessionRecs;
    }

    public function individualRegistrationPeriods()
    {
        return SpecialRegistrationPeriod::where(['student_id' => $this->id])->orderBy('created_at', 'DESC')->get();
    }

    public static function highestSession($programmeId)
    {
        return RegistrationPeriod::where(['programme_id' => $programmeId])
            ->orderBy('session', 'DESC')
            ->first();
    }

    public function canApplyForTransfer()
    {
//        if (strtoupper(Auth::user()->matric_number) == 'U08CS1024')
//            return true;
//        else
//            return false;

        if (strtoupper($this->mode_of_entry) != 'UG')
            return false;

        $sessionReg = SessionReg::where(['student_id' => $this->id])
            ->orderBy('session', 'DESC')->first();
        if (!$sessionReg) return false;

        if ($level = Level::find($sessionReg->level_id)) {
            if (!$programme = Programme::find($sessionReg->programme_id))
                return false;

            $formSetting = null;
            if ($level->number >= 3) {
                $formSetting = $programme->lowestFormSession($sessionReg->session);
            } else if ($level->number == 2) {
                $formSetting = $programme->lowestFormSession($sessionReg->session + 1);
            }

            if ($formSetting) {
                $val = array_filter($programme->availableSessions($this->entry_session),
                    function ($value) use ($formSetting, $sessionReg) {
                        return $value > $sessionReg->session && $value < $formSetting->session;
                    });

                if (count($val) == 0)
                    return $formSetting;
            }
        }
        return false;
    }

    public function isPGStudent()
    {
        $ptype = $this->programme()->programmetype()->first()->prog_type_code;
        return trim(strtoupper($ptype)) == "PG";
    }

    public function isUGStudent()
    {
        $ptype = $this->programme()->programmetype()->first()->prog_type_code;
        return trim(strtoupper($ptype)) == "UG";
    }

    public function similarStudentsIds(SessionReg $sessionReg)
    {
        $isNew = $this->entry_session == $sessionReg->session ? 1 : 2;
        $residency = $this->residency;
        $programme = Programme::find($sessionReg->programme_id);
        $department = Department::find($programme->department_id);
        $faculty = Faculty::find($department->faculty_id);

        return Student::where(['residency' => $residency, 'entry_session' => $this->entry_session])
            ->join('session_regs', function ($join) use ($sessionReg) {
                $join->on('session_regs.student_id', '=', 'students.id')
                    ->on('session_regs.session', '=', DB::raw($sessionReg->session));
            })
            ->where('session_regs.level_id', $sessionReg->level_id)
            ->pluck('students.id');

    }

    public function similarSessionRegIds(SessionReg $sessionReg)
    {
        $residency = $this->residency;

        return Student::where(['residency' => $residency, 'entry_session' => $this->entry_session])
            ->join('session_regs', function ($join) use ($sessionReg) {
                $join->on('session_regs.student_id', '=', 'students.id')
                    ->on('session_regs.session', '=', DB::raw($sessionReg->session));
            })
            ->where('session_regs.level_id', $sessionReg->level_id)
            ->pluck('session_regs.id');

    }

    public function recordFees()
    {
        // try {
            $sessionRegs = SessionReg::where(['student_id' => $this->id])
                ->whereNull('session_fee')
                ->get();

            foreach ($sessionRegs as $sessionReg) {
                $sfees = $this->sessionFees($sessionReg->session);
                $amount = $sfees['total'];
                $sessRegIds = $this->similarSessionRegIds($sessionReg);
                SessionReg::whereIn('id', $sessRegIds)->update(['session_fee' => $amount]);
            }
        // } catch (\Exception $e) {

        // }
    }

    public function paymentOptions($session, $checkId = null)
    {

        $sessionReg = SessionReg::where(['student_id' => $this->id, 'session' => $session])->first();
        return $sessionReg->getPaymentOptions($checkId);
    }

    public function cleanCourseRegistration($session)
    {
        $invalidCG = CourseRegistration::where(["student_id" => $this->id, "course_group_id" => 0])->pluck('id')->toArray();
        $course_regs = CourseRegistration::join("course_groups", function ($join) use ($session) {
            $join->on("course_groups.id", "=", "course_registrations.course_group_id")
                ->on("course_groups.session", "=", DB::raw($session));
        })->where(["student_id" => $this->id, "course_groups.course_id" => 0])->pluck('course_registrations.id')->toArray();

        CourseRegistration::whereIn('id', array_merge($invalidCG, $course_regs))->delete();
    }

    public function mySessionReg($session)
    {
        return $this->sessionReg()->where(['session' => $session])->first();
    }

    public function selectedOption($session)
    {
        return $this->mySessionReg($session)->selectedOption();
    }

    public function generatedOption($session)
    {
        return Transaction::where(['student_id' => $this->id, "code" => "REG"])
            ->whereNotNull("flexible_index")->pluck("flexible_index")->toArray();
    }

    public function transEquiv($session, $amount, $status = 'Not Paid')
    {
        return Transaction::where(
            [
                "student_id" => $this->id,
                'transaction_amount' => $amount,
                "payment_status" => $status,
                "code" => "REG",
                "session" => $session
            ])->first();
    }

    public function isFinalYear()
    {
       $latestSession = $this->sessionReg()->first();
        if ($latestSession) {
            $prg = $latestSession->programme();
            if ($prg) {
                if ($this->mode_of_entry == "PG") {
                   $duration = $prg->programme_type_id == 13 ? 7 : ($prg->programme_type_id == 14 ? 8 : 9);
                } else {
                    $duration = $prg->duration;
                }

                $level = Level::where(['number' => $duration, 'programme_type_id' => $prg->programme_type_id])->first();

                return $level ? ( $level->id == $latestSession->level_id ? $level : false) : false;
            }
        }
        return false;
    }

    public function isYearOne()
    {

        $latestSession = $this->sessionReg()->first();
        if ($latestSession) {
            $prg = $latestSession->programme();
            if ($prg) {
                if ($this->mode_of_entry == "PG") {
                    $duration = $prg->programme_type_id == 13 ? 7 : ($prg->programme_type_id == 14 ? 8 : 9);
                } else {
                    $duration = 1;
                }
                $level = Level::where(['number' => $duration, 'programme_type_id' => $prg->programme_type_id])->first();

                return $level ?( $level->id == $latestSession->level_id?$level:false) : false;
            }
        }
        return false;
    }

    public function isYearN($year)
    {
        $latestSession = $this->sessionReg()->first();
        if ($latestSession) {
            $prg = $latestSession->programme();
            if ($prg) {
                $duration = $year;
                $level = Level::where(['number' => $duration, 'programme_type_id' => $prg->programme_type_id])->first();

                return $level ? ( $level->id == $latestSession->level_id?$level:false) : false;
            }
        }
        return false;
    }

    public function isDirectEntry()
    {
        if ($this->mode_of_entry == "UG") {
            return $this->entry_level_id == 4;
        }
        return false;
    }

    public function isSpecialAdmission()
    {
        if ($this->mode_of_entry == "UG") {
            return $this->entry_level_id == 5;
        }
        return false;
    }

    public function canDoResit($session)
    {
        $latestSession = $this->sessionReg()->first();
        // return true;
        if (!$latestSession) return false;
        if ($session != $latestSession->session) return false;
        if (!$rConfig = $this->canResit()) return false;
        return true;

    }

    public function canResit(): ?ResitConfiguration
    {
        // Old code (hardcoded to 2023 - commented out):
        // $latestSession = $this->sessionReg()->where('session',2023)->first();
        $latestSession = $this->sessionReg()->orderBy('session', 'DESC')->first();
        if (!$latestSession)
            return null;

        if($rconx = $this->hasPrivateResit($latestSession->session)){
            return ResitConfiguration::find($rconx->resit_id);
        }

        $prg = $latestSession->programme();
        $department = $prg->department();
        $faculty = $department->faculty();
        $lvl = $latestSession->level();
        $lvls = Level::where(['programme_type_id' => $prg->programme_type_id])->orderBy('number', 'ASC')->pluck('id', 'number')->all();
        $lvlArr = [];
        if ($o = $this->isYearOne()) {
            $lvlArr[] = 'Year One';
            $lvlArr[] = $lvls[$o->number];
        }
        if ($this->isYearN(2)) {
            $lvlArr[] = $lvls[2];
        }
        if ($this->isYearN(3)) {
            $lvlArr[] = $lvls[3];
        }
        if ($this->isYearN(4)) {
            $lvlArr[] = $lvls[4];
        }
        if ($this->isYearN(5)) {
            $lvlArr[] = $lvls[5];
        }
        if ($this->isYearN(6)) {
            $lvlArr[] = $lvls[6];
        }
        if ($f = $this->isFinalYear()) {
            $lvlArr[] = 'Final Year';
            $lvlArr[] = $lvls[$f->number];
        }
        if ($this->isDirectEntry()) {
            $lvlArr[] = "Direct Entry";
        }
        if ($this->isSpecialAdmission()) {
            $lvlArr[] = "Special Admission";
        }
        if ($this->isSpillOver()) {
            $lvlArr[] = 'Spill Over';
        }

        if($this->isFinalResidenncy()){
            $lvlArr[] = 'Final Residency';
        }

        // If no level matches found, student cannot resit
//        if (empty($lvlArr)) {
//            return null;
//        }

//        Check to make sure if that student's latest session is the current session
//        to avoid people paying for previous years
        $regPeriod = $prg->currentRegistrationPeriod();
        if ($regPeriod && $regPeriod->session != $latestSession->session) {
            return null;
        }
        if ($this->residencyExhausted()) {
            return null;
        }

        // return $lvlArr;
        // First try to find a specific match (non-wildcard configurations)
        // Prioritize configurations that match the student's specific faculty/department/programme
        $rconf = ResitConfiguration::where(['session' => $latestSession->session])
            ->whereIn('level_id', $lvlArr)
            ->where('level_id', "<>",'Private Resit')
            ->where(function($query) use ($faculty, $department, $prg) {
                // Match specific faculty, department, and programme (most specific)
                $query->where(function($q) use ($faculty, $department, $prg) {
                    $q->where('faculty_id', $faculty->id)
                      ->where('department_id', $department->id)
                      ->where('programme_id', $prg->id);
                })
                // Or match specific faculty and department, but wildcard programme
                ->orWhere(function($q) use ($faculty, $department) {
                    $q->where('faculty_id', $faculty->id)
                      ->where('department_id', $department->id)
                      ->where('programme_id', 0);
                })
                // Or match specific faculty, but wildcard department and programme
                ->orWhere(function($q) use ($faculty) {
                    $q->where('faculty_id', $faculty->id)
                      ->where('department_id', 0)
                      ->where('programme_id', 0);
                })
                // Or match wildcard faculty, department, and programme (least specific)
                ->orWhere(function($q) {
                    $q->where('faculty_id', 0)
                      ->where('department_id', 0)
                      ->where('programme_id', 0);
                });
            })
            ->where('mode_of_entry', $this->mode_of_entry)
            ->whereDate('start_date', "<=", today())
            ->whereDate('end_date', ">=", today())
            ->orderByRaw('CASE
                WHEN faculty_id != 0 AND department_id != 0 AND programme_id != 0 THEN 1
                WHEN faculty_id != 0 AND department_id != 0 AND programme_id = 0 THEN 2
                WHEN faculty_id != 0 AND department_id = 0 AND programme_id = 0 THEN 3
                ELSE 4
            END')
            ->first();
//        if(in_array(strtolower($this->matric_number),['u16ac1055'])){
//            return ResitConfiguration::first();
//        }

        if($rconf)
            return $rconf;
        // Old code (undefined $session variable - commented out):
        // if($rconx = $this->hasPrivateResit($session)){


        return null;
    }


    public function hasPrivateResit($session){

        $resits = ResitConfiguration::where(['session' => $session,'level_id'=>'Private Resit'])->pluck('id');
        return $privResit = ResitStudent::whereIn('resit_id',$resits)->where(['student_id'=>$this->id])->first();
        // resit_students
    }

    public function residencySessions()
    {
        $sessionRegs = $this->sessionReg()->groupBy('session')->get();

        $residencySessions = [];
        foreach ($sessionRegs as $sessionReg) {
            $disciplinaryCases = Discipline::where('session', '>=', $sessionReg->session)
                ->where('end_session', '<=', $sessionReg->session)
                ->where("student_id", $this->id)->get();
                $hasCase = 0;
            foreach ($disciplinaryCases as $disciplinaryCase) {
                if (in_array($disciplinaryCase->nature, ['Warning']) || $sessionReg->status == 'Differed') {
                    $hasCase = 1;
                }
            }
            if(!$hasCase){
                $residencySessions[] = $sessionReg->session;
            }
        }

        return $residencySessions;
    }

    public function canPay()
    {
        $latestSession = $this->sessionReg()->first();
        if (!$latestSession) return false;
//        Rustication,Expulsion,Warning,Suspension,Revocation,end_session,end_semester,nature
        $disciplinaryCases = Discipline::where('session', '>=', $latestSession->session)
            ->where('end_session', '<=', $latestSession->session)
            ->where("student_id", $this->id)->get();
        foreach ($disciplinaryCases as $disciplinaryCase) {
            if (in_array($disciplinaryCase->nature, ['Expulsion']) || $latestSession->graduation_status == "Withdrawn") {
                return false;
            }
        }
        return true;
    }

    public function isSpillOver()
    {
        $latestSession = $this->sessionReg()->first();
        if ($latestSession) {
            $prg = $latestSession->programme();
            $entryLevel = Level::find($this->entry_level_id);
            if ($prg) {
                $duration = $this->mode_of_entry == "PG" ? $prg->duration * 1.5 : ($prg->duration - ($entryLevel->number - 1)) * 1.5;
                $residencySessions = $this->residencySessions();
                return $duration < count($residencySessions);

            }
        }
        return false;
    }

    public function isFinalResidenncy()
    {
        $latestSession = $this->sessionReg()->first();
        if ($latestSession) {
            $prg = $latestSession->programme();
            $entryLevel = Level::find($this->entry_level_id);
            if ($prg) {
                $duration = $this->mode_of_entry == "PG" ? $prg->duration * 1.5 : ($prg->duration - ($entryLevel->number - 1)) * 1.5;
                $residencySessions = $this->residencySessions();
                // return $duration . " " . count($residencySessions);
                return $duration <= count($residencySessions);

            }
        }
        return false;
    }

    public function _resitSessions()
    {
//        $rConfig = $this->canResit();
        return ResitCourse::where(['resit_courses.student_id' => $this->id, "transactions.code" => "RST"])
            ->leftJoin('transactions', function ($join) {
                $join->on('transactions.session', "=", "resit_courses.session")
                    ->on("transactions.student_id", "=", "resit_courses.student_id");
            })
            ->groupBy('resit_courses.session')
            ->select([
                DB::raw('SUM(amount) as amount_due'),
                DB::raw("IF(transactions.transaction_amount,IF(transactions.payment_status<>'Not Paid',transactions.transaction_amount,0),0) AS amount_paid"),
                DB::raw("COUNT(resit_courses.id) AS id"),
                "resit_courses.session"
            ]);
    }

    public function resitSessions()
    {
        return $this->_resitSessions()->get();
    }

    public function resitSession($session)
    {
        return $this->_resitSessions()->where('resit_courses.session', $session)->get();
    }

    public function resits($session)
    {

        return ResitCourse::where(['student_id' => $this->id, 'session' => $session])
            ->orderBy('course_unit');
    }

    public function __resitTransaction($session){
        return Transaction::where(['student_id' => $this->id, 'session' => $session, 'code' => "RST"]);
    }

    public function resitTransaction($session)
    {
        return Transaction::where(['student_id' => $this->id, 'session' => $session, 'code' => "RST"])->orderBy('payment_status', 'DESC')->get();
    }

    public function enteredBefore($session)
    {
        return $this->entry_session < $session;
    }

    public function enteredAfter($session)
    {
        return $this->entry_session > $session;
    }

    public function isBelowP18()
    {
        return $this->isPGStudent() && $this->enteredBefore(2019);
    }

    public function isBelowP23()
    {
        return $this->isPGStudent() && $this->enteredBefore(2023);
    }

    public function paymentBtnToShow($session)
    {
//        return 1 to show payment Btn, 2 to show Sundry Btn and 0 to show nothing and 3 to show details


        $ret = $this->isNew($session) ? "New" : "Returning";
        $reg = RegistrationPeriod::where(["session" => $session, "programme_id" => $this->sessionProgramme($session)->id, "nature" => "FEE", "new_returning" => $ret])
            ->orderBy('session', 'DESC')
            ->orderBy('end_date', 'DESC')
            ->first();
        $date = \Carbon\Carbon::parse($reg->end_date);
        $open = $date >= \Carbon\Carbon::today() || $this->isRegOpen($session);
        $hasPaid = $this->feesClearedForSession($session);
        if ($this->isPGStudent()) {
            //target returning student only from 2021 ignore new
            $hasPaidSundry = $this->hasPaidSundryFor($session);

            if ($this->isNew($session) && $session == 2021) {
                return 1 ? ($hasPaid ? 3 : 1) : ($hasPaid ? 3 : 0);
            } elseif ($session >= 2021) {
                return $hasPaidSundry ? ($hasPaid ? 3 : 1) : 2;
            } else {
                return $hasPaid ? 3 : 1;
            }

        } else {
            return $open ? ($hasPaid ? 3 : 1) : ($hasPaid ? 3 : 0);
        }

    }

    public function hasPaidSundryFor($session)
    {
        $fees_ = FeeManager::computeStudentSundryCharges($this, $session, 'PSC', 1);

        $amount = $fees_->sum('amount');

        $details = (object)SundryTransaction::paySundryStudent($this, $amount, $session);

        return $details->totalAmountPaid >= $details->amountPayable;
    }

    public function ePublication()
    {
//        return Publication::where(['student_id' => $this->id]);
        return $this->hasOne(Publication::class, 'student_id');
    }

    public function pendingSet($session, $semester)
    {
        $courseGroups = $this->belongsToMany(CourseGroup::class, 'course_registrations')
            ->where(['course_groups.session' => $session, 'course_groups.semester' => $semester])
            ->get();
        $cgId = [];
        foreach ($courseGroups as $courseGroup) {
            $cgId[$courseGroup->course_group_id] = $courseGroup->course_id;
        }

        $cgs = SetResponse::whereNotIn('course_group_id', array_keys($cgId))
            ->where('student_id', $this->id)->pluck('course_group_id');
        $courses = CourseGroup::whereIn('course_groups.id', $cgs)
            ->join('courses', 'courses.id', '=', 'course_groups.course_id')->get();
        if (count($cgs) == 0) {
            return count($courseGroups) && count($courses) == 0;
        } else {
            return $courses;
        }

    }

    public function reservations()
    {
        return $this->hasMany(Reservation::class);
    }

    public function accTransactions()
    {
        return $this->hasManyThrough(Transaction::class, Reservation::class, 'student_id', 'student_id', 'id', 'id');
    }

    public function accommodationBlacklist(){
        return AccommodationBlacklist::where(['student_id'=>$this->id])->get();
    }

    public function hasActiveBlacklist($session=0){
        if(!$session){
            $sessReg = $this->sessionReg()->first();
            if(!$sessReg)
                return false;

            $session = $sessReg->session;
        }
        return AccommodationBlacklist::where(['student_id'=>$this->id])->whereRaw("(start_session <= $session ) AND (type='Forever' OR end_session>=$session)")->first();
    }

    private function acDetails(){
        $sessionReg = $this->sessionReg()->first();
        $programme = $sessionReg->programme();
        $department = $programme->department();
        $faculty = $department->faculty();
        $campus = $faculty->campus;
        $mode_of_entry = $this->mode_of_entry;
        $level_id = $sessionReg->level_id;

        return [
            'campus'=>$campus,'faculty_id'=>$faculty->id,'department_id'=>$department->id,
            'programme_id'=>$programme->id,'level_id'=>$level_id,'mode_of_entry'=>$mode_of_entry,
        ];
    }

    public function isEligibleForAccommodation()
    {
        $config = AccommodationConfig::where('is_active',1)->first();
        $confString = $config->isEligible($this->acDetails());
        return substr($confString,-1);
    }

    /**
     * Recursive evaluation of configurations.
     */
    protected function evaluateConfigs($studentDetails, $configs, $parentId = null)
    {
        $isEligible = false;

        foreach ($configs as $config) {
            if ($config->parent_id == $parentId ) {
                if ($config->type === 'Exclude' && $this->matchesConditions($studentDetails, $config)) {
                    // Exclusion has the highest precedence
                    return false;
                } elseif ($config->type === 'Include' && $this->matchesConditions($studentDetails, $config)) {
                    // Inclusion makes the student eligible
                    $isEligible = true;
                }

                // Recursively evaluate child configurations
                $childConfigs = $configs->where('parent_id', $config->id);
                $childEligibility = $this->evaluateConfigs($studentDetails, $childConfigs, $config->id);

                // Combine child eligibility with current eligibility
                $isEligible = $childEligibility || $isEligible;
            }
        }

        return $isEligible;
        }

    /**
     * Check if a student matches a single configuration.
     */
    protected function matchesConditions($studentDetails, $config)
    {
        return (
            ($config->campus === 0 || $config->campus == $studentDetails['campus']) &&
            // ($config->programme_type === 0 || $config->programme_type == $studentDetails['programme_type']) &&
            ($config->faculty_id === 0 || $config->faculty_id == $studentDetails['faculty_id']) &&
            ($config->department_id === 0 || $config->department_id == $studentDetails['department_id']) &&
            ($config->programme_id === 0 || $config->programme_id == $studentDetails['programme_id']) &&
            ($config->level_id === 0 || $config->level_id == $studentDetails['level_id']) &&
            ($config->mode_of_entry === 0 || $config->mode_of_entry == $studentDetails['mode_of_entry'])
            // && ($config->programme_mode === 0 || $config->programme_mode == $studentDetails['programme_mode'])
        );
    }

    /**
     * Generate human-readable configuration hierarchy.
     */
    public function generateHumanReadableConfigs($configs, $parentId = null, $level = 0)
    {
        $output = '';

        foreach ($configs as $config) {
            if ($config->parent_id == $parentId) {
                $indent = str_repeat('--', $level);
                $output .= "{$indent} {$config->type}: ";
                $output .= $this->describeConfig($config) . PHP_EOL;

                // Recursive call for children
                $output .= $this->generateHumanReadableConfigs($configs, $config->id, $level + 1);
            }
        }

        return $output;
    }

    /**
     * Describe a single configuration in human-readable format.
     */
    protected function describeConfig($config)
    {
        $descriptions = [];

        if ($config->campus) $descriptions[] = "Campus {$config->campus}";
        if ($config->faculty_id) $descriptions[] = "Faculty {$config->faculty_id}";
        if ($config->department_id) $descriptions[] = "Department {$config->department_id}";
        if ($config->level_id) $descriptions[] = "Level {$config->level_id}";
        if ($config->programme_id) $descriptions[] = "Programme {$config->programme_id}";
        if ($config->programme_type) $descriptions[] = "Type {$config->programme_type}";

        return implode(', ', $descriptions) ?: 'All Students';
    }


    public function programmeActiveSessionBetween($sessOne,$sessTwo)
    {
        return RegistrationPeriod::where(['programme_id'=>$this->programme_id])->whereBetween($sessOne,$sessTwo)->pluck('session');
    }
}
