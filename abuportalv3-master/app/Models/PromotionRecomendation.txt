<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class PromotionRecomendation extends Model
{
    use HasFactory;

    protected $guarded = [];
    
    // Specify the correct table name
    protected $table = 'promotion_recomendations';

    public static function populatePromotionRecomendation($employees, $year)
    {
        $emps = [];
        foreach ($employees as $employee) {
            $emp = Employee::find($employee->employee_id);
            $qualification = $emp->orderedQualification();
            $q = isset($qualification[0]) ? $qualification[0]->qualification . " " . $qualification[0]->course : "";
            $dept = $emp->department;
            $fac = $dept->faculty();
            $comp = $fac->complex();
            $emps[] = [
                "employee_id" => $employee->employee_id,
                "personnel_no" => $employee->personnel_no,
                "title" => $employee->title,
                "name" => $employee->fullname,
                "dofapt" => $employee->date_of_first_appointment,
                "doc" => $employee->date_of_confirmation,
                "dolp" => $employee->date_of_last_promotion,
                "rank_on_employment" => $employee->rank_on_employment,
                "present_salary_step" => $employee->rank . " / " . $employee->grade,
                "year" => $year,
                "student_supervised" => json_encode($employee->splitSupervision()),
                "highest_qualification" => $q,
                "publications" => json_encode($emp->splitPublication()),
                "rank_on_employment" => $emp->rank_on_employment,
                "department_name" => $dept->name,
                "department_id" => $dept->id,
                "complex_name" => $comp ? $comp->name : "",
                "complex_id" => $comp ? $comp->id : "",
                "faculty_name" => $fac->name,
                "faculty_id" => $fac->id,
            ];
        }

        foreach (array_chunk($emps, 1000) as $t) {
            PromotionRecomendation::upsert($t, ['employee_id', 'year'], ["personnel_no", "title", "name", "dofapt", "doc", "dolp", "rank_on_employment", "present_salary_step", "student_supervised", "highest_qualification", "publications", "rank_on_employment", "department_name", "department_id", "complex_name", "complex_id", "faculty_name", "faculty_id",]);
        }
    }

    public function hodRecommended()
    {
        return $this->unit_status != "Pending";
    }

    public function deanRecommended()
    {
        return $this->faculty_status != "Pending";
    }

    public function cchRecommended()
    {
        return $this->complex_status != "Pending";
    }

    public function recommendHOD($request)
    {
        $rank = Rank::find($request->recommended_rank_id);
        $comment = empty($this->unit_recommendation) ? [] : json_decode($this->unit_recommendation);
        $comment[] = $request->reasons;
        $this->unit_status = $request->recommendation;
        $this->unit_recommendation = json_encode($comment);
        $this->recommended_rank = $rank ? $rank->name : "";
        $this->recommended_rank_id = $rank ? $request->recommended_rank_id : "";
        $this->faculty_status = "Pending";
        $this->complex_status = "Pending";
        $this->save();
    }

    public function recommendDean($request)
    {

        if ($request->recommendation == "Return") {
            $this->unit_status = "Pending";
        } else {
            $this->faculty_status = $request->recommendation;
        }
        $comment = empty($this->faculty_recommendation) ? [] : json_decode($this->faculty_recommendation);
        $comment[] = $request->reasons;
        $this->faculty_recommendation = json_encode($comment);
        $this->save();
    }

    public function recommendComplexChairman($request)
    {
        if ($request->recommendation == "Return") {
            $this->unit_status = "Pending";
            $this->faculty_status = "Pending";
        } else {
            $this->complex_status = $request->recommendation;
        }

        $comment = empty($this->complex_recommendation) ? [] : json_decode($this->complex_recommendation);
        $comment[] = $request->reasons;
        $this->complex_recommendation = json_encode($comment);
        $this->save();
    }

    public function complex_recommendation()
    {
        $pot = empty($this->complex_recommendation) ? "" : $this->complex_recommendation;
        $potArr = json_decode($pot);
        $potArr = empty($potArr) ? [] : $potArr;
        return empty($this->complex_recommendation) ? "" : "<ol><li>" . implode("</li><li>", $potArr) . "</ol>";
    }

    public function unit_recommendation()
    {
        $pot = empty($this->unit_recommendation) ? "" : $this->unit_recommendation;
        $potArr = json_decode($pot);
        $potArr = empty($potArr) ? [] : $potArr;
        return empty($this->unit_recommendation) ? "" : "<ol><li>" . implode("</li><li>", $potArr) . "</ol>";
    }

    public function faculty_recommendation()
    {
        $pot = empty($this->faculty_recommendation) ? "" : $this->faculty_recommendation;
        $potArr = json_decode($pot);
        $potArr = empty($potArr) ? [] : $potArr;
        return empty($this->faculty_recommendation) ? "" : "<ol><li>" . implode("</li><li>", $potArr) . "</ol>";
    }

    public function rank()
    {
        return $this->belongsTo(Rank::class, 'recommended_rank_id');
    }

    public function apc_rank()
    {
        return $this->belongsTo(Rank::class, 'apc_rank_id');
    }

    public function apc_grade()
    {
        return $this->belongsTo(Rank::class, 'apc_grade_id');
    }

    public function faculty()
    {
        return $this->belongsTo(Faculty::class, 'faculty_id');
    }

    public function structure()
    {
        return $this->belongsTo(EmployeeSalaryStructure::class, 'apc_grade_id');
    }

    public function promotionDate()
    {
        return \Carbon\Carbon::parse($this->updated_at)->format('jS F, Y');
    }

    public function recommendedSalary()
    {
        $this->apc_rank_id;
        $rank = Rank::find($this->apc_rank_id);
        $rankSplit = explode(" ",$rank->gradelevel);
        $salaryScale = trim($rankSplit[0]);
        $gradeStep = explode("/",$rankSplit[1]);
        // return json_encode(['structure'=>$salaryScale,'level'=>$gradeStep[0],'step'=>$this->apc_step]);
        $salary = EmployeeSalaryStructure::where(['structure'=>$salaryScale,'level'=>$gradeStep[0],'step'=>intval($this->apc_step)])->first();
        return $salary;
    }

    public function recommendedSalaryText()
    {
        $salary = $this->recommendedSalary();
        return ($salary?number_format($salary->salary,2):"0,000,000.00");
    }

    public function employee()
    {
        return $this->belongsTo(Employee::class,"employee_id");
    }

    /**
     * Get the user who verified this recommendation
     */
    public function verifier()
    {
        return $this->belongsTo(User::class, 'verified_by');
    }

    /**
     * Get the user who withdrew this recommendation
     */
    public function withdrawnBy()
    {
        return $this->belongsTo(User::class, 'withdrawn_by');
    }

    /**
     * Check if recommendation is verified
     */
    public function isVerified()
    {
        return $this->verification_status === 'Approved';
    }

    /**
     * Check if recommendation is pending verification
     */
    public function isPendingVerification()
    {
        return $this->verification_status === 'Pending' || is_null($this->verification_status);
    }

    /**
     * Check if recommendation is rejected
     */
    public function isRejected()
    {
        return $this->verification_status === 'Rejected';
    }

    /**
     * Scope for verified recommendations
     */
    public function scopeVerified($query)
    {
        return $query->where('verification_status', 'Approved');
    }

    /**
     * Scope for pending verification
     */
    public function scopePendingVerification($query)
    {
        return $query->where(function($q) {
            $q->where('verification_status', 'Pending')
              ->orWhereNull('verification_status');
        });
    }

    /**
     * Scope for rejected recommendations
     */
    public function scopeRejected($query)
    {
        return $query->where('verification_status', 'Rejected');
    }

    /**
     * Check if recommendation is withdrawn
     */
    public function isWithdrawn()
    {
        return $this->council_approval === 'Withdrawn';
    }

    /**
     * Scope for withdrawn recommendations
     */
    public function scopeWithdrawn($query)
    {
        return $query->where('council_approval', 'Withdrawn');
    }
}
